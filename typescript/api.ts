/* tslint:disable */
/* eslint-disable */
/**
 * Safe Checkout
 * Simple, yet elegant web interfaces for your convenience. One request away from your first secured C2C transaction.
 *
 * The version of the OpenAPI document: 2.0.28
 * Contact: noc@tripartie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessError
 */
export interface AccessError {
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiClientPostCreationRead
 */
export interface ApiClientPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'identifier'?: string;
    /**
     * 
     * @type {any}
     * @memberof ApiClientPostCreationRead
     */
    'secret'?: any;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiClientRead
 */
export interface ApiClientRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientRead
     */
    'scopes'?: Array<ApiClientReadScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'name'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientReadScopesEnum {
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH',
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    OrganizationRead = 'ORGANIZATION_READ'
}

/**
 * 
 * @export
 * @interface ApiClientWrite
 */
export interface ApiClientWrite {
    /**
     * 
     * @type {string}
     * @memberof ApiClientWrite
     */
    'referenceName'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientWrite
     */
    'desiredScopes'?: Array<ApiClientWriteDesiredScopesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientWriteDesiredScopesEnum {
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    OrganizationRead = 'ORGANIZATION_READ',
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH'
}

/**
 * 
 * @export
 * @interface AuthError
 */
export interface AuthError {
    /**
     * 
     * @type {number}
     * @memberof AuthError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BankAccountRead
 */
export interface BankAccountRead {
    /**
     * 
     * @type {string}
     * @memberof BankAccountRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccountRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccountRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof BankAccountRead
     */
    'processorStatus'?: BankAccountReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum BankAccountReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface BankAccountUserRead
 */
export interface BankAccountUserRead {
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'bic': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'processorStatus'?: BankAccountUserReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum BankAccountUserReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface BankAccountWrite
 */
export interface BankAccountWrite {
    /**
     * 
     * @type {string}
     * @memberof BankAccountWrite
     */
    'iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountWrite
     */
    'bic': string;
}
/**
 * 
 * @export
 * @interface CardCollectionRead
 */
export interface CardCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'primaryAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'brand'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<CardMetadataCollectionRead>}
     * @memberof CardCollectionRead
     */
    'metadata'?: Array<CardMetadataCollectionRead>;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardCollectionRead
     */
    'iri'?: string;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof CardCollectionRead
     */
    'processorStatus'?: CardCollectionReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CardCollectionReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface CardMetadataCollectionRead
 */
export interface CardMetadataCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof CardMetadataCollectionRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardMetadataCollectionRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface CardMetadataRead
 */
export interface CardMetadataRead {
    /**
     * 
     * @type {string}
     * @memberof CardMetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardMetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface CardMetadataUpdate
 */
export interface CardMetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof CardMetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardMetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface CardRead
 */
export interface CardRead {
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'primaryAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'brand'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<CardMetadataRead>}
     * @memberof CardRead
     */
    'metadata'?: Array<CardMetadataRead>;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardRead
     */
    'iri'?: string;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof CardRead
     */
    'processorStatus'?: CardReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CardReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface CardUpdate
 */
export interface CardUpdate {
    /**
     * 
     * @type {Array<CardMetadataUpdate>}
     * @memberof CardUpdate
     */
    'metadata'?: Array<CardMetadataUpdate>;
}
/**
 * 
 * @export
 * @interface CardUserRead
 */
export interface CardUserRead {
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'primaryAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'brand'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CardUserRead
     */
    'ephemeral'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CardUserRead
     */
    'iri'?: string;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof CardUserRead
     */
    'processorStatus'?: CardUserReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CardUserReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface CardWrite
 */
export interface CardWrite {
    /**
     * 
     * @type {boolean}
     * @memberof CardWrite
     */
    'ephemeral': boolean;
}
/**
 * 
 * @export
 * @interface CashoutCashOutCollectionRead
 */
export interface CashoutCashOutCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof CashoutCashOutCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CashoutCashOutCollectionRead
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutCollectionRead
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutCollectionRead
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutCollectionRead
     */
    'bic': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutCollectionRead
     */
    'status': CashoutCashOutCollectionReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutCollectionRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutCollectionRead
     */
    'confirmedAt': string;
}

/**
    * @export
    * @enum {string}
    */
export enum CashoutCashOutCollectionReadStatusEnum {
    Created = 'created',
    Submitted = 'submitted',
    Refused = 'refused',
    Blocked = 'blocked',
    Accepted = 'accepted'
}

/**
 * 
 * @export
 * @interface CashoutCashOutRead
 */
export interface CashoutCashOutRead {
    /**
     * 
     * @type {number}
     * @memberof CashoutCashOutRead
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CashoutCashOutRead
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'bic': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'status': CashoutCashOutReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'confirmedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof CashoutCashOutRead
     */
    'processorStatus'?: CashoutCashOutReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CashoutCashOutReadStatusEnum {
    Created = 'created',
    Submitted = 'submitted',
    Refused = 'refused',
    Blocked = 'blocked',
    Accepted = 'accepted'
}
/**
    * @export
    * @enum {string}
    */
export enum CashoutCashOutReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface CashoutCashOutWrite
 */
export interface CashoutCashOutWrite {
    /**
     * 
     * @type {string}
     * @memberof CashoutCashOutWrite
     */
    'captcha'?: string | null;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface InvalidQueryError
 */
export interface InvalidQueryError {
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'publicUrl': string;
    /**
     * 
     * @type {File}
     * @memberof Media
     */
    'file'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'b64EncodedTmpFile'?: string | null;
    /**
     * Associated 374x374 pixels small thumbnail
     * @type {string}
     * @memberof Media
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'original'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Media
     */
    'offers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaRead
 */
export interface MediaRead {
    /**
     * 
     * @type {number}
     * @memberof MediaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'publicUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaUserRead
 */
export interface MediaUserRead {
    /**
     * 
     * @type {number}
     * @memberof MediaUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MediaUserRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MessageError
 */
export interface MessageError {
    /**
     * 
     * @type {string}
     * @memberof MessageError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'card'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'value'?: string | null;
}
/**
 * This error can occurs when you reference objects in the query that does not exist.
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Offer
 */
export interface Offer {
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'status': OfferStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'captcha'?: string | null;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof Offer
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof Offer
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'url': string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'seller': string;
    /**
     * Limit the offer to a particular buyer. Useful if the offer was issued from an auction for instance.
     * @type {string}
     * @memberof Offer
     */
    'presetBuyer'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof Offer
     */
    'nature': OfferNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'minNegotiableUnitPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Offer
     */
    'allowToNegotiateUnitPrice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'condition'?: OfferConditionEnum;
    /**
     * Accepted values between 500g (0.5kg) and 10,000g (10kg).
     * @type {number}
     * @memberof Offer
     */
    'weightInGram': number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof Offer
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof Offer
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof Offer
     */
    'shippingCarriers'?: Array<OfferShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof Offer
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<Metadata>}
     * @memberof Offer
     */
    'metadata'?: Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Offer
     */
    'medias': Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Offer
     */
    'views': Array<View>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Offer
     */
    'transactions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Offer
     */
    'quotes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'presetBuyerId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'sellerId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    'halfPricePoint'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferAddressIndependentWrite
 */
export interface OfferAddressIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferCollectionRead
 */
export interface OfferCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'status': OfferCollectionReadStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'seller': string;
    /**
     * Limit the offer to a particular buyer. Useful if the offer was issued from an auction for instance.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'presetBuyer'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'nature': OfferCollectionReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'minNegotiableUnitPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OfferCollectionRead
     */
    'allowToNegotiateUnitPrice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'condition'?: OfferCollectionReadConditionEnum;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferCollectionRead
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferCollectionRead
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferCollectionRead
     */
    'shippingCarriers'?: Array<OfferCollectionReadShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'iri'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferIndependentWrite
 */
export interface OfferIndependentWrite {
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {OfferPersonaIndependentWrite}
     * @memberof OfferIndependentWrite
     */
    'seller': OfferPersonaIndependentWrite;
    /**
     * 
     * @type {OfferPersonaIndependentWrite}
     * @memberof OfferIndependentWrite
     */
    'presetBuyer'?: OfferPersonaIndependentWrite | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'nature'?: OfferIndependentWriteNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'minNegotiableUnitPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'allowToNegotiateUnitPrice': boolean;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'currencyCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'condition'?: OfferIndependentWriteConditionEnum;
    /**
     * Accepted values between 500g (0.5kg) and 10,000g (10kg).
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'weightInGram'?: number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Set<string>}
     * @memberof OfferIndependentWrite
     */
    'shippingCarriers'?: Set<OfferIndependentWriteShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'canBeSoldSeparately'?: boolean;
    /**
     * 
     * @type {Array<OfferMetadataIndependentWrite>}
     * @memberof OfferIndependentWrite
     */
    'metadata'?: Array<OfferMetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferMediaRead
 */
export interface OfferMediaRead {
    /**
     * 
     * @type {number}
     * @memberof OfferMediaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OfferMetadataIndependentWrite
 */
export interface OfferMetadataIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataIndependentWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataIndependentWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferMetadataUpdate
 */
export interface OfferMetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferOrganizationRead
 */
export interface OfferOrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {OfferMediaRead}
     * @memberof OfferOrganizationRead
     */
    'icon'?: OfferMediaRead | null;
    /**
     * 
     * @type {OfferMediaRead}
     * @memberof OfferOrganizationRead
     */
    'logo'?: OfferMediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'primaryColor'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferPersonaIndependentWrite
 */
export interface OfferPersonaIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'gender': OfferPersonaIndependentWriteGenderEnum;
    /**
     * 
     * @type {any}
     * @memberof OfferPersonaIndependentWrite
     */
    'dateOfBirth'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {OfferAddressIndependentWrite}
     * @memberof OfferPersonaIndependentWrite
     */
    'address'?: OfferAddressIndependentWrite | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<OfferMetadataIndependentWrite>}
     * @memberof OfferPersonaIndependentWrite
     */
    'metadata'?: Array<OfferMetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferPersonaIndependentWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface OfferPersonaRead
 */
export interface OfferPersonaRead {
    /**
     * Determine if the Persona have a Tripartie account
     * @type {boolean}
     * @memberof OfferPersonaRead
     */
    'registered'?: boolean;
}
/**
 * 
 * @export
 * @interface OfferPostCreationRead
 */
export interface OfferPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof OfferPostCreationRead
     */
    'ulid'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferPostCreationRead
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferPostCreationRead
     */
    'presetBuyerId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OfferPostCreationRead
     */
    'sellerId'?: number | null;
}
/**
 * 
 * @export
 * @interface OfferRead
 */
export interface OfferRead {
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'status': OfferReadStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferRead
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferRead
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {OfferOrganizationRead}
     * @memberof OfferRead
     */
    'organization'?: OfferOrganizationRead | null;
    /**
     * 
     * @type {OfferPersonaRead}
     * @memberof OfferRead
     */
    'seller': OfferPersonaRead;
    /**
     * 
     * @type {OfferPersonaRead}
     * @memberof OfferRead
     */
    'presetBuyer'?: OfferPersonaRead | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferRead
     */
    'nature': OfferReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'condition'?: OfferReadConditionEnum;
    /**
     * Accepted values between 500g (0.5kg) and 10,000g (10kg).
     * @type {number}
     * @memberof OfferRead
     */
    'weightInGram': number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferRead
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferRead
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferRead
     */
    'shippingCarriers'?: Array<OfferReadShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferRead
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<OfferMediaRead>}
     * @memberof OfferRead
     */
    'medias': Array<OfferMediaRead>;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'iri'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferReadStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferSoloWrite
 */
export interface OfferSoloWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferSoloWrite
     */
    'captcha'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferSoloWrite
     */
    'nature'?: OfferSoloWriteNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferSoloWrite
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferSoloWrite
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferSoloWrite
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OfferSoloWrite
     */
    'minNegotiableUnitPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OfferSoloWrite
     */
    'allowToNegotiateUnitPrice': boolean;
    /**
     * 
     * @type {string}
     * @memberof OfferSoloWrite
     */
    'currencyCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferSoloWrite
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferSoloWrite
     */
    'condition'?: OfferSoloWriteConditionEnum;
    /**
     * Accepted values between 500g (0.5kg) and 10,000g (10kg).
     * @type {number}
     * @memberof OfferSoloWrite
     */
    'weightInGram'?: number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferSoloWrite
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferSoloWrite
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Set<string>}
     * @memberof OfferSoloWrite
     */
    'shippingCarriers'?: Set<OfferSoloWriteShippingCarriersEnum>;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferSoloWrite
     */
    'canBeSoldSeparately'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferSoloWriteNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferSoloWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferSoloWriteShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferUpdate
 */
export interface OfferUpdate {
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferUpdate
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferUpdate
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'minNegotiableUnitPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'allowToNegotiateUnitPrice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'currencyCode'?: string;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Set<string>}
     * @memberof OfferUpdate
     */
    'shippingCarriers'?: Set<OfferUpdateShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'canBeSoldSeparately'?: boolean;
    /**
     * 
     * @type {Array<OfferMetadataUpdate>}
     * @memberof OfferUpdate
     */
    'metadata'?: Array<OfferMetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferUpdateShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OrganizationAddressUpdate
 */
export interface OrganizationAddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationCollectionRead
 */
export interface OrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {OrganizationMediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'icon'?: OrganizationMediaCollectionRead | null;
    /**
     * 
     * @type {OrganizationMediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'logo'?: OrganizationMediaCollectionRead | null;
}
/**
 * 
 * @export
 * @interface OrganizationMediaCollectionRead
 */
export interface OrganizationMediaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationMediaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OrganizationMediaRead
 */
export interface OrganizationMediaRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationMediaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OrganizationRead
 */
export interface OrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {OrganizationMediaRead}
     * @memberof OrganizationRead
     */
    'icon'?: OrganizationMediaRead | null;
    /**
     * 
     * @type {OrganizationMediaRead}
     * @memberof OrganizationRead
     */
    'logo'?: OrganizationMediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'primaryColor'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationUpdate
 */
export interface OrganizationUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {OrganizationAddressUpdate}
     * @memberof OrganizationUpdate
     */
    'billingAddress'?: OrganizationAddressUpdate | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'primaryColor'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationUserRead
 */
export interface OrganizationUserRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof OrganizationUserRead
     */
    'icon'?: MediaUserRead | null;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof OrganizationUserRead
     */
    'logo'?: MediaUserRead | null;
}
/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {any}
     * @memberof Persona
     */
    'dateOfBirth'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof Persona
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Persona
     */
    'address'?: Address | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<Metadata>}
     * @memberof Persona
     */
    'metadata'?: Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'offers': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'purchases': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'ownedBy'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof Persona
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'purchaseCount'?: number;
    /**
     * Determine if the Persona have a Tripartie account
     * @type {boolean}
     * @memberof Persona
     */
    'registered'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaAddressRead
 */
export interface PersonaAddressRead {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAddressUpdate
 */
export interface PersonaAddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAddressWrite
 */
export interface PersonaAddressWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaCollectionRead
 */
export interface PersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'purchaseCount'?: number;
}
/**
 * 
 * @export
 * @interface PersonaMetadataRead
 */
export interface PersonaMetadataRead {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataUpdate
 */
export interface PersonaMetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataWrite
 */
export interface PersonaMetadataWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRead
 */
export interface PersonaRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'gender'?: PersonaReadGenderEnum;
    /**
     * 
     * @type {any}
     * @memberof PersonaRead
     */
    'dateOfBirth'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressRead}
     * @memberof PersonaRead
     */
    'address'?: PersonaAddressRead | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataRead>}
     * @memberof PersonaRead
     */
    'metadata'?: Array<PersonaMetadataRead>;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'purchaseCount'?: number;
    /**
     * Determine if the Persona have a Tripartie account
     * @type {boolean}
     * @memberof PersonaRead
     */
    'registered'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaReadGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaUpdate
 */
export interface PersonaUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'gender': PersonaUpdateGenderEnum;
    /**
     * 
     * @type {any}
     * @memberof PersonaUpdate
     */
    'dateOfBirth'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaUpdate
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressUpdate}
     * @memberof PersonaUpdate
     */
    'address'?: PersonaAddressUpdate | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataUpdate>}
     * @memberof PersonaUpdate
     */
    'metadata'?: Array<PersonaMetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaUpdateGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaUserRead
 */
export interface PersonaUserRead {
    /**
     * 
     * @type {OrganizationUserRead}
     * @memberof PersonaUserRead
     */
    'organization'?: OrganizationUserRead | null;
}
/**
 * 
 * @export
 * @interface PersonaWrite
 */
export interface PersonaWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'gender': PersonaWriteGenderEnum;
    /**
     * 
     * @type {any}
     * @memberof PersonaWrite
     */
    'dateOfBirth'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressWrite}
     * @memberof PersonaWrite
     */
    'address'?: PersonaAddressWrite | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataWrite>}
     * @memberof PersonaWrite
     */
    'metadata'?: Array<PersonaMetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface ProofOfIdentityCollectionRead
 */
export interface ProofOfIdentityCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'status': ProofOfIdentityCollectionReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'type': ProofOfIdentityCollectionReadTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'originalFilename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof ProofOfIdentityCollectionRead
     */
    'processorStatus'?: ProofOfIdentityCollectionReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityCollectionReadStatusEnum {
    Drafted = 'drafted',
    Uploaded = 'uploaded',
    Submitted = 'submitted',
    Accepted = 'accepted',
    Refused = 'refused',
    Blocked = 'blocked'
}
/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityCollectionReadTypeEnum {
    NationalId = 'national_id',
    Passport = 'passport'
}
/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityCollectionReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface ProofOfIdentityRead
 */
export interface ProofOfIdentityRead {
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'status': ProofOfIdentityReadStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'type': ProofOfIdentityReadTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'originalFilename'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof ProofOfIdentityRead
     */
    'processorStatus'?: ProofOfIdentityReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityReadStatusEnum {
    Drafted = 'drafted',
    Uploaded = 'uploaded',
    Submitted = 'submitted',
    Accepted = 'accepted',
    Refused = 'refused',
    Blocked = 'blocked'
}
/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityReadTypeEnum {
    NationalId = 'national_id',
    Passport = 'passport'
}
/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface ProofOfIdentityWrite
 */
export interface ProofOfIdentityWrite {
    /**
     * 
     * @type {string}
     * @memberof ProofOfIdentityWrite
     */
    'type': ProofOfIdentityWriteTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProofOfIdentityWriteTypeEnum {
    NationalId = 'national_id',
    Passport = 'passport'
}

/**
 * Someone has to ask for a Quote prior to create a transaction and (therefor) charging a known amount of money.
 * @export
 * @interface QuoteRead
 */
export interface QuoteRead {
    /**
     * 
     * @type {string}
     * @memberof QuoteRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof QuoteRead
     */
    'shippingCarrier'?: QuoteReadShippingCarrierEnum | null;
    /**
     * 
     * @type {string}
     * @memberof QuoteRead
     */
    'pickupCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuoteRead
     */
    'quantityToBeAcquired': number;
    /**
     * 
     * @type {number}
     * @memberof QuoteRead
     */
    'attemptUnitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuoteRead
     */
    'transactionFees'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuoteRead
     */
    'shippingFees'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuoteRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuoteRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof QuoteRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuoteRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof QuoteRead
     */
    'price'?: number | null;
    /**
     * The buyer pays for:  - A) item  - B) shipping (optional)  - C) fees     (optional) This method sum them automatically.
     * @type {number}
     * @memberof QuoteRead
     */
    'buyerTotal'?: number | null;
    /**
     * Represent what amount is to be expected released to the seller.
     * @type {number}
     * @memberof QuoteRead
     */
    'sellerTotal'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum QuoteReadShippingCarrierEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay',
    Null = 'null'
}

/**
 * Someone has to ask for a Quote prior to create a transaction and (therefor) charging a known amount of money.
 * @export
 * @interface QuoteUpdate
 */
export interface QuoteUpdate {
    /**
     * 
     * @type {string}
     * @memberof QuoteUpdate
     */
    'shippingCarrier'?: QuoteUpdateShippingCarrierEnum | null;
    /**
     * 
     * @type {string}
     * @memberof QuoteUpdate
     */
    'pickupCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuoteUpdate
     */
    'quantityToBeAcquired': number;
    /**
     * 
     * @type {number}
     * @memberof QuoteUpdate
     */
    'attemptUnitPrice'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum QuoteUpdateShippingCarrierEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay',
    Null = 'null'
}

/**
 * Someone has to ask for a Quote prior to create a transaction and (therefor) charging a known amount of money.
 * @export
 * @interface QuoteWrite
 */
export interface QuoteWrite {
    /**
     * 
     * @type {string}
     * @memberof QuoteWrite
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuoteWrite
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuoteWrite
     */
    'shippingCarrier'?: QuoteWriteShippingCarrierEnum | null;
    /**
     * 
     * @type {string}
     * @memberof QuoteWrite
     */
    'pickupCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof QuoteWrite
     */
    'quantityToBeAcquired': number;
    /**
     * 
     * @type {number}
     * @memberof QuoteWrite
     */
    'attemptUnitPrice'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum QuoteWriteShippingCarrierEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface RateLimitError
 */
export interface RateLimitError {
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface TransactionCardRead
 */
export interface TransactionCardRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionCardRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof TransactionCardRead
     */
    'processorStatus'?: TransactionCardReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionCardReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface TransactionCollectionRead
 */
export interface TransactionCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionOfferCollectionRead}
     * @memberof TransactionCollectionRead
     */
    'offer': TransactionOfferCollectionRead;
    /**
     * 
     * @type {TransactionQuoteCollectionRead}
     * @memberof TransactionCollectionRead
     */
    'quote': TransactionQuoteCollectionRead;
    /**
     * 
     * @type {TransactionPersonaCollectionRead}
     * @memberof TransactionCollectionRead
     */
    'buyer': TransactionPersonaCollectionRead;
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'status'?: TransactionCollectionReadStatusEnum | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCollectionRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCollectionRead
     */
    'supplementalFees'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionCollectionRead
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionCollectionRead
     */
    'totalCharged'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionCollectionRead
     */
    'totalFees'?: number;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'awaitedParty'?: TransactionCollectionReadAwaitedPartyEnum;
    /**
     * Yield if eligible the date-time at which the transaction state expire.
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'statusExpiration'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof TransactionCollectionRead
     */
    'processorStatus'?: TransactionCollectionReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionCollectionReadStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Blocked = 'BLOCKED',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED',
    Cancelled = 'CANCELLED',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionCollectionReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionCollectionReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface TransactionMetadataRead
 */
export interface TransactionMetadataRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionMetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionMetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface TransactionOfferCollectionRead
 */
export interface TransactionOfferCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'status': TransactionOfferCollectionReadStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {TransactionPersonaCollectionRead}
     * @memberof TransactionOfferCollectionRead
     */
    'seller': TransactionPersonaCollectionRead;
    /**
     * 
     * @type {TransactionPersonaCollectionRead}
     * @memberof TransactionOfferCollectionRead
     */
    'presetBuyer'?: TransactionPersonaCollectionRead | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'nature': TransactionOfferCollectionReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOfferCollectionRead
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionOfferCollectionRead
     */
    'minNegotiableUnitPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOfferCollectionRead
     */
    'allowToNegotiateUnitPrice'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOfferCollectionRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'condition'?: TransactionOfferCollectionReadConditionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionOfferCollectionRead
     */
    'medias': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferCollectionRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferCollectionReadStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferCollectionReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferCollectionReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}

/**
 * 
 * @export
 * @interface TransactionOfferRead
 */
export interface TransactionOfferRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'status': TransactionOfferReadStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {TransactionPersonaRead}
     * @memberof TransactionOfferRead
     */
    'seller': TransactionPersonaRead;
    /**
     * 
     * @type {TransactionPersonaRead}
     * @memberof TransactionOfferRead
     */
    'presetBuyer'?: TransactionPersonaRead | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'nature': TransactionOfferReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionOfferRead
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOfferRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'condition'?: TransactionOfferReadConditionEnum;
    /**
     * Accepted values between 500g (0.5kg) and 10,000g (10kg).
     * @type {number}
     * @memberof TransactionOfferRead
     */
    'weightInGram': number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof TransactionOfferRead
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof TransactionOfferRead
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof TransactionOfferRead
     */
    'shippingCarriers'?: Array<TransactionOfferReadShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof TransactionOfferRead
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<TransactionMetadataRead>}
     * @memberof TransactionOfferRead
     */
    'metadata'?: Array<TransactionMetadataRead>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionOfferRead
     */
    'medias': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOfferRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferReadStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionOfferReadShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface TransactionParcelRead
 */
export interface TransactionParcelRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'carrier': TransactionParcelReadCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionParcelRead
     */
    'price'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'status'?: TransactionParcelReadStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'labelPublicUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionParcelRead
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionParcelReadCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionParcelReadStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface TransactionPersonaCollectionRead
 */
export interface TransactionPersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof TransactionPersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionPersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionPersonaCollectionRead
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface TransactionPersonaRead
 */
export interface TransactionPersonaRead {
    /**
     * 
     * @type {number}
     * @memberof TransactionPersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionPersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionPersonaRead
     */
    'lastName'?: string;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof TransactionPersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionPersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionPersonaRead
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof TransactionPersonaRead
     */
    'address'?: object;
    /**
     * Determine if the Persona have a Tripartie account
     * @type {boolean}
     * @memberof TransactionPersonaRead
     */
    'registered'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionQuoteCollectionRead
 */
export interface TransactionQuoteCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteCollectionRead
     */
    'shippingCarrier'?: TransactionQuoteCollectionReadShippingCarrierEnum | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteCollectionRead
     */
    'pickupCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'quantityToBeAcquired': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'attemptUnitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'transactionFees'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'shippingFees'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteCollectionRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteCollectionRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'price'?: number | null;
    /**
     * The buyer pays for:  - A) item  - B) shipping (optional)  - C) fees     (optional) This method sum them automatically.
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'buyerTotal'?: number | null;
    /**
     * Represent what amount is to be expected released to the seller.
     * @type {number}
     * @memberof TransactionQuoteCollectionRead
     */
    'sellerTotal'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionQuoteCollectionReadShippingCarrierEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface TransactionQuoteRead
 */
export interface TransactionQuoteRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteRead
     */
    'shippingCarrier'?: TransactionQuoteReadShippingCarrierEnum | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteRead
     */
    'pickupCode'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'quantityToBeAcquired': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'attemptUnitPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'transactionFees'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'shippingFees'?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionQuoteRead
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'unitPrice'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'price'?: number | null;
    /**
     * The buyer pays for:  - A) item  - B) shipping (optional)  - C) fees     (optional) This method sum them automatically.
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'buyerTotal'?: number | null;
    /**
     * Represent what amount is to be expected released to the seller.
     * @type {number}
     * @memberof TransactionQuoteRead
     */
    'sellerTotal'?: number | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionQuoteReadShippingCarrierEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface TransactionRead
 */
export interface TransactionRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'ulid': string;
    /**
     * 
     * @type {TransactionOfferRead}
     * @memberof TransactionRead
     */
    'offer': TransactionOfferRead;
    /**
     * 
     * @type {TransactionQuoteRead}
     * @memberof TransactionRead
     */
    'quote': TransactionQuoteRead;
    /**
     * 
     * @type {TransactionPersonaRead}
     * @memberof TransactionRead
     */
    'buyer': TransactionPersonaRead;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'status'?: TransactionReadStatusEnum | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'fees'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'supplementalFees'?: number | null;
    /**
     * 
     * @type {TransactionCardRead}
     * @memberof TransactionRead
     */
    'card'?: TransactionCardRead | null;
    /**
     * 
     * @type {TransactionWalletRead}
     * @memberof TransactionRead
     */
    'escrow'?: TransactionWalletRead | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'remotePreAuthorizationId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'remotePayInId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'balanceToRefund'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'feesToRefund'?: number | null;
    /**
     * Shipping is never refunded on purpose. Once deposited (parcel), we are billed for it.
     * @type {boolean}
     * @memberof TransactionRead
     */
    'forceRefundShipping'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'review'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'rating'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'handOverCode'?: string | null;
    /**
     * 
     * @type {Array<TransactionParcelRead>}
     * @memberof TransactionRead
     */
    'parcels'?: Array<TransactionParcelRead>;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'totalCharged'?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionRead
     */
    'totalFees'?: number;
    /**
     * Determine who is awaited (actor) for the next transition
     * @type {string}
     * @memberof TransactionRead
     */
    'awaitedParty'?: TransactionReadAwaitedPartyEnum;
    /**
     * Yield if eligible the date-time at which the transaction state expire.
     * @type {string}
     * @memberof TransactionRead
     */
    'statusExpiration'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof TransactionRead
     */
    'processorStatus'?: TransactionReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionReadStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Blocked = 'BLOCKED',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED',
    Cancelled = 'CANCELLED',
    Null = 'null'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionReadAwaitedPartyEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface TransactionUpdate
 */
export interface TransactionUpdate {
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    'status'?: TransactionUpdateStatusEnum | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionUpdate
     */
    'supplementalFees'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionUpdate
     */
    'balanceToRefund'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionUpdate
     */
    'feesToRefund'?: number | null;
    /**
     * Shipping is never refunded on purpose. Once deposited (parcel), we are billed for it.
     * @type {boolean}
     * @memberof TransactionUpdate
     */
    'forceRefundShipping'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    'review'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TransactionUpdate
     */
    'rating'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    'handOverCodeConfirmation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdate
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionUpdateStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Blocked = 'BLOCKED',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED',
    Cancelled = 'CANCELLED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface TransactionWalletRead
 */
export interface TransactionWalletRead {
    /**
     * 
     * @type {string}
     * @memberof TransactionWalletRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionWalletRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionWalletRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof TransactionWalletRead
     */
    'processorStatus'?: TransactionWalletReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionWalletReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface TransactionWrite
 */
export interface TransactionWrite {
    /**
     * 
     * @type {string}
     * @memberof TransactionWrite
     */
    'captcha'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TransactionWrite
     */
    'offer': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionWrite
     */
    'quote': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionWrite
     */
    'card'?: string | null;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<UnprocessableEntityViolationsInner>}
     * @memberof UnprocessableEntity
     */
    'violations'?: Array<UnprocessableEntityViolationsInner>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntityViolationsInner
 */
export interface UnprocessableEntityViolationsInner {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'propertyPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface UserAuthenticatedRead
 */
export interface UserAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {object}
     * @memberof UserAuthenticatedRead
     */
    'mainAddress'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserAuthenticatedRead
     */
    'roles': Array<UserAuthenticatedReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The nationality of the current user.
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'originCountry'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'homeCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'avatar'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'lockdown': boolean;
    /**
     * 
     * @type {UserOrganizationAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'organization'?: UserOrganizationAuthenticatedRead | null;
    /**
     * 
     * @type {UserBankAccountAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'bankAccount'?: UserBankAccountAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'identityVerifiedAt'?: string | null;
    /**
     * 
     * @type {Array<UserPersonaAuthenticatedRead>}
     * @memberof UserAuthenticatedRead
     */
    'profiles': Array<UserPersonaAuthenticatedRead>;
    /**
     * 
     * @type {Array<UserCardAuthenticatedRead>}
     * @memberof UserAuthenticatedRead
     */
    'cards'?: Array<UserCardAuthenticatedRead>;
    /**
     * 
     * @type {UserWalletAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'wallet'?: UserWalletAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'secondAuthFactor'?: boolean;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'processorStatus'?: UserAuthenticatedReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserAuthenticatedReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAuthenticatedReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserBankAccountAuthenticatedRead
 */
export interface UserBankAccountAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'iban'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'bic': string;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'processorStatus'?: UserBankAccountAuthenticatedReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserBankAccountAuthenticatedReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserCardAuthenticatedRead
 */
export interface UserCardAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'primaryAccountNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'expireAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'countryCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'brand'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserCardAuthenticatedRead
     */
    'ephemeral'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'iri'?: string;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserCardAuthenticatedRead
     */
    'processorStatus'?: UserCardAuthenticatedReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCardAuthenticatedReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserCollectionRead
 */
export interface UserCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {object}
     * @memberof UserCollectionRead
     */
    'mainAddress'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCollectionRead
     */
    'roles': Array<UserCollectionReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserCollectionRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaCollectionRead}
     * @memberof UserCollectionRead
     */
    'avatar'?: UserMediaCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserOrganizationCollectionRead}
     * @memberof UserCollectionRead
     */
    'organization'?: UserOrganizationCollectionRead | null;
    /**
     * 
     * @type {UserWalletCollectionRead}
     * @memberof UserCollectionRead
     */
    'wallet'?: UserWalletCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCollectionRead
     */
    'secondAuthFactor'?: boolean;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserCollectionRead
     */
    'processorStatus'?: UserCollectionReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCollectionReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}
/**
    * @export
    * @enum {string}
    */
export enum UserCollectionReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserEmailValidationWrite
 */
export interface UserEmailValidationWrite {
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'emailVerificationInput': string | null;
}
/**
 * 
 * @export
 * @interface UserInvite
 */
export interface UserInvite {
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInvite
     */
    'invitedRole': Array<UserInviteInvitedRoleEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UserInviteInvitedRoleEnum {
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserJwtCreated
 */
export interface UserJwtCreated {
    /**
     * 
     * @type {string}
     * @memberof UserJwtCreated
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UserJwtWrite
 */
export interface UserJwtWrite {
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'captcha'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'totpInput'?: string;
}
/**
 * 
 * @export
 * @interface UserMediaAuthenticatedRead
 */
export interface UserMediaAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserMediaAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserMediaAuthenticatedRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaCollectionRead
 */
export interface UserMediaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserMediaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserMediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaRead
 */
export interface UserMediaRead {
    /**
     * 
     * @type {number}
     * @memberof UserMediaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaSupportRead
 */
export interface UserMediaSupportRead {
    /**
     * 
     * @type {number}
     * @memberof UserMediaSupportRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserMediaSupportRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserOrganizationAuthenticatedRead
 */
export interface UserOrganizationAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'icon'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'logo'?: UserMediaAuthenticatedRead | null;
}
/**
 * 
 * @export
 * @interface UserOrganizationCollectionRead
 */
export interface UserOrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationCollectionRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserOrganizationRead
 */
export interface UserOrganizationRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationRead
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'domainVerified'?: boolean;
    /**
     * 
     * @type {UserMediaRead}
     * @memberof UserOrganizationRead
     */
    'icon'?: UserMediaRead | null;
    /**
     * 
     * @type {UserMediaRead}
     * @memberof UserOrganizationRead
     */
    'logo'?: UserMediaRead | null;
}
/**
 * 
 * @export
 * @interface UserOrganizationSupportRead
 */
export interface UserOrganizationSupportRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationSupportRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationSupportRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserPersonaAuthenticatedRead
 */
export interface UserPersonaAuthenticatedRead {
    /**
     * 
     * @type {UserOrganizationAuthenticatedRead}
     * @memberof UserPersonaAuthenticatedRead
     */
    'organization'?: UserOrganizationAuthenticatedRead | null;
}
/**
 * 
 * @export
 * @interface UserPostRegisterRead
 */
export interface UserPostRegisterRead {
    /**
     * 
     * @type {number}
     * @memberof UserPostRegisterRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPostRegisterRead
     */
    'iri'?: string;
}
/**
 * 
 * @export
 * @interface UserSupportRead
 */
export interface UserSupportRead {
    /**
     * 
     * @type {number}
     * @memberof UserSupportRead
     */
    'id'?: number;
    /**
     * 
     * @type {object}
     * @memberof UserSupportRead
     */
    'mainAddress'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSupportRead
     */
    'roles': Array<UserSupportReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSupportRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaSupportRead}
     * @memberof UserSupportRead
     */
    'avatar'?: UserMediaSupportRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserOrganizationSupportRead}
     * @memberof UserSupportRead
     */
    'organization'?: UserOrganizationSupportRead | null;
    /**
     * 
     * @type {UserWalletSupportRead}
     * @memberof UserSupportRead
     */
    'wallet'?: UserWalletSupportRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSupportRead
     */
    'secondAuthFactor'?: boolean;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserSupportRead
     */
    'processorStatus'?: UserSupportReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserSupportReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}
/**
    * @export
    * @enum {string}
    */
export enum UserSupportReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserTotpSetupRead
 */
export interface UserTotpSetupRead {
    /**
     * 
     * @type {string}
     * @memberof UserTotpSetupRead
     */
    'totpUri'?: string | null;
}
/**
 * 
 * @export
 * @interface UserTotpToggleWrite
 */
export interface UserTotpToggleWrite {
    /**
     * 
     * @type {boolean}
     * @memberof UserTotpToggleWrite
     */
    'totpEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserTotpToggleWrite
     */
    'totpChallenge': string | null;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {object}
     * @memberof UserUpdate
     */
    'mainAddress'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'consentMailAds': boolean;
}
/**
 * 
 * @export
 * @interface UserUserEmailUpdate
 */
export interface UserUserEmailUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUserEmailUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUserEmailUpdate
     */
    'plainPassword': string | null;
}
/**
 * 
 * @export
 * @interface UserUserPasswordUpdate
 */
export interface UserUserPasswordUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUserPasswordUpdate
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserPasswordUpdate
     */
    'newPassword': string | null;
}
/**
 * 
 * @export
 * @interface UserUserRead
 */
export interface UserUserRead {
    /**
     * 
     * @type {number}
     * @memberof UserUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {object}
     * @memberof UserUserRead
     */
    'mainAddress'?: object;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUserRead
     */
    'roles'?: Array<UserUserReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The nationality of the current user.
     * @type {string}
     * @memberof UserUserRead
     */
    'originCountry'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserUserRead
     */
    'homeCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof UserUserRead
     */
    'avatar'?: MediaUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'consentMailAds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'lockdown'?: boolean;
    /**
     * 
     * @type {OrganizationUserRead}
     * @memberof UserUserRead
     */
    'organization'?: OrganizationUserRead | null;
    /**
     * 
     * @type {BankAccountUserRead}
     * @memberof UserUserRead
     */
    'bankAccount'?: BankAccountUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'identityVerifiedAt'?: string | null;
    /**
     * 
     * @type {Array<PersonaUserRead>}
     * @memberof UserUserRead
     */
    'profiles'?: Array<PersonaUserRead>;
    /**
     * 
     * @type {Array<CardUserRead>}
     * @memberof UserUserRead
     */
    'cards'?: Array<CardUserRead>;
    /**
     * 
     * @type {WalletUserRead}
     * @memberof UserUserRead
     */
    'wallet'?: WalletUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'secondAuthFactor'?: boolean;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserUserRead
     */
    'processorStatus'?: UserUserReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserUserReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}
/**
    * @export
    * @enum {string}
    */
export enum UserUserReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * Disable a user account
 * @export
 * @interface UserUserSubscribed
 */
export interface UserUserSubscribed {
    /**
     * 
     * @type {number}
     * @memberof UserUserSubscribed
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUserSubscribed
     */
    'iri'?: string;
}
/**
 * 
 * @export
 * @interface UserWalletAuthenticatedRead
 */
export interface UserWalletAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserWalletAuthenticatedRead
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserWalletAuthenticatedRead
     */
    'processorStatus'?: UserWalletAuthenticatedReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserWalletAuthenticatedReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserWalletCollectionRead
 */
export interface UserWalletCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserWalletCollectionRead
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserWalletCollectionRead
     */
    'processorStatus'?: UserWalletCollectionReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserWalletCollectionReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserWalletSupportRead
 */
export interface UserWalletSupportRead {
    /**
     * 
     * @type {number}
     * @memberof UserWalletSupportRead
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'externalId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof UserWalletSupportRead
     */
    'processorStatus'?: UserWalletSupportReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserWalletSupportReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface UserWrite
 */
export interface UserWrite {
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The nationality of the current user.
     * @type {string}
     * @memberof UserWrite
     */
    'originCountry'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserWrite
     */
    'homeCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailAds'?: boolean;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'user'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'namedSource'?: ViewNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface WalletUserRead
 */
export interface WalletUserRead {
    /**
     * 
     * @type {number}
     * @memberof WalletUserRead
     */
    'balance'?: number;
    /**
     * 
     * @type {string}
     * @memberof WalletUserRead
     */
    'currency': string;
    /**
     * 
     * @type {string}
     * @memberof WalletUserRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WalletUserRead
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof WalletUserRead
     */
    'providerName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WalletUserRead
     */
    'providerCreatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WalletUserRead
     */
    'providerUpdatedAt'?: string | null;
    /**
     * Automagically infer on what state the entity is at the Payment Processor.
     * @type {string}
     * @memberof WalletUserRead
     */
    'processorStatus'?: WalletUserReadProcessorStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum WalletUserReadProcessorStatusEnum {
    Unallocated = 'unallocated',
    Allocating = 'allocating',
    Allocated = 'allocated',
    Freed = 'freed',
    Outdated = 'outdated'
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'event'?: WebhookEventEnum;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'iri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {WebhookObject}
     * @memberof Webhook
     */
    'object'?: WebhookObject;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryCollectionRead
 */
export interface WebhookHistoryCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'event': WebhookHistoryCollectionReadEventEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryCollectionRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryCollectionReadEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryRead
 */
export interface WebhookHistoryRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'event': WebhookHistoryReadEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookHistoryRead
     */
    'normalizedObject'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'responseBody'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryReadEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookObject
 */
export interface WebhookObject {
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'status': WebhookObjectStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof WebhookObject
     */
    'publicUrl'?: string;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof WebhookObject
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {OfferOrganizationRead}
     * @memberof WebhookObject
     */
    'organization'?: OfferOrganizationRead;
    /**
     * 
     * @type {OfferPersonaRead}
     * @memberof WebhookObject
     */
    'seller': OfferPersonaRead;
    /**
     * 
     * @type {OfferPersonaRead}
     * @memberof WebhookObject
     */
    'presetBuyer'?: OfferPersonaRead;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof WebhookObject
     */
    'nature': WebhookObjectNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'condition'?: WebhookObjectConditionEnum;
    /**
     * Accepted values between 500g (0.5kg) and 10,000g (10kg).
     * @type {number}
     * @memberof WebhookObject
     */
    'weightInGram': number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof WebhookObject
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof WebhookObject
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof WebhookObject
     */
    'shippingCarriers'?: Array<WebhookObjectShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'eanCode'?: string;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof WebhookObject
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<OfferMediaRead>}
     * @memberof WebhookObject
     */
    'medias': Array<OfferMediaRead>;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'gender'?: WebhookObjectGenderEnum;
    /**
     * 
     * @type {any}
     * @memberof WebhookObject
     */
    'dateOfBirth'?: any;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof WebhookObject
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'mobilePhoneNumber'?: string;
    /**
     * 
     * @type {PersonaAddressRead}
     * @memberof WebhookObject
     */
    'address'?: PersonaAddressRead;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataRead>}
     * @memberof WebhookObject
     */
    'metadata'?: Array<PersonaMetadataRead>;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof WebhookObject
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'purchaseCount'?: number;
    /**
     * Determine if the Persona have a Tripartie account
     * @type {boolean}
     * @memberof WebhookObject
     */
    'registered'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionRead
 */
export interface WebhookSubscriptionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookSubscriptionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'event'?: WebhookSubscriptionReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'webhookSecret': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionReadEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionWrite
 */
export interface WebhookSubscriptionWrite {
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'event'?: WebhookSubscriptionWriteEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'callbackUrl': string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionWriteEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added',
    Null = 'null'
}


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierDelete', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierGet', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost: async (apiClientWrite: ApiClientWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiClientWrite' is not null or undefined
            assertParamExists('apiApiClientsPost', 'apiClientWrite', apiClientWrite)
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiClientWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost: async (userInvite: UserInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvite' is not null or undefined
            assertParamExists('apiInvitePost', 'userInvite', userInvite)
            const localVarPath = `/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection: async (page?: number, itemsPerPage?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['itemsPerPage'] = itemsPerPage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdGet', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIddisablePatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIddisablePatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIddisablePatch', 'body', body)
            const localVarPath = `/users/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdenablePatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdenablePatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIdenablePatch', 'body', body)
            const localVarPath = `/users/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost: async (userJwtWrite?: UserJwtWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userJwtWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiClientRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiApiClientsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierDelete(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiApiClientsIdentifierDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierGet(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiApiClientsIdentifierGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsPost(apiClientWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiApiClientsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvitePost(userInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiInvitePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsGetCollection(page, itemsPerPage, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiOrganizationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiOrganizationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiUsersGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSupportRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIddisablePatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserSubscribed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIddisablePatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiUsersIddisablePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserSubscribed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdenablePatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.apiUsersIdenablePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJwtCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationPost(userJwtWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.authenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiClientRead>> {
            return localVarFp.apiApiClientsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiApiClientsIdentifierDelete(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiClientRead> {
            return localVarFp.apiApiClientsIdentifierGet(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig): AxiosPromise<ApiClientPostCreationRead> {
            return localVarFp.apiApiClientsPost(apiClientWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiInvitePost(userInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrganizationCollectionRead>> {
            return localVarFp.apiOrganizationsGetCollection(page, itemsPerPage, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationRead> {
            return localVarFp.apiOrganizationsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserCollectionRead>> {
            return localVarFp.apiUsersGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSupportRead> {
            return localVarFp.apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIddisablePatch(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<UserUserSubscribed> {
            return localVarFp.apiUsersIddisablePatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<UserUserSubscribed> {
            return localVarFp.apiUsersIdenablePatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig): AxiosPromise<UserJwtCreated> {
            return localVarFp.authenticationPost(userJwtWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Retrieves the collection of ApiClient resources.
     * @summary Retrieves the collection of ApiClient resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiApiClientsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the ApiClient resource.
     * @summary Removes the ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiApiClientsIdentifierDelete(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a ApiClient resource.
     * @summary Retrieves a ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiApiClientsIdentifierGet(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a ApiClient resource.
     * @summary Creates a ApiClient resource.
     * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiApiClientsPost(apiClientWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to your organization workspace
     * @summary Organization invite
     * @param {UserInvite} userInvite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiInvitePost(userInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Organization resources.
     * @summary Retrieves the collection of Organization resources.
     * @param {number} [page] The collection page number
     * @param {number} [itemsPerPage] The number of items per page
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiOrganizationsGetCollection(page, itemsPerPage, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Organization resource.
     * @summary Retrieves a Organization resource.
     * @param {string} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiOrganizationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of User resources.
     * @summary Retrieves the collection of User resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiUsersGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiUsersIddisablePatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiUsersIddisablePatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).apiUsersIdenablePatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
     * @summary User authentication
     * @param {UserJwtWrite} [userJwtWrite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).authenticationPost(userJwtWrite, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch: async (id: string, organizationUpdate: OrganizationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'id', id)
            // verify required parameter 'organizationUpdate' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'organizationUpdate', organizationUpdate)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconDelete', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconPost', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoDelete', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoPost', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdPatch(id, organizationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserOrganizationRead> {
            return localVarFp.apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdiconDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdiconPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdlogoDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdlogoPost(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * Updates the Organization resource.
     * @summary Update your Organization details, branding or parameters
     * @param {string} id Organization identifier
     * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Icon
     * @param {number} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization Icon
     * @param {number} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Logo
     * @param {number} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization logo
     * @param {number} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection: async (page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (email2) {
                localVarQueryParameter['email[]'] = email2;
            }

            if (mobilePhoneNumber !== undefined) {
                localVarQueryParameter['mobilePhoneNumber'] = mobilePhoneNumber;
            }

            if (mobilePhoneNumber2) {
                localVarQueryParameter['mobilePhoneNumber[]'] = mobilePhoneNumber2;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (dateOfBirthBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[before]'] = dateOfBirthBefore;
            }

            if (dateOfBirthStrictlyBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_before]'] = dateOfBirthStrictlyBefore;
            }

            if (dateOfBirthAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[after]'] = dateOfBirthAfter;
            }

            if (dateOfBirthStrictlyAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_after]'] = dateOfBirthStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdDelete', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdGet', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch: async (id: string, personaUpdate: PersonaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'id', id)
            // verify required parameter 'personaUpdate' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'personaUpdate', personaUpdate)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost: async (personaWrite: PersonaWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaWrite' is not null or undefined
            assertParamExists('apiPersonasPost', 'personaWrite', personaWrite)
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonaCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdPatch(id, personaUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPost(personaWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PersonaCollectionRead>> {
            return localVarFp.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiPersonasIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasPost(personaWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * Retrieves the collection of Persona resources.
     * @summary Retrieves the collection of Persona resources.
     * @param {number} [page] The collection page number
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {Array<string>} [email2] 
     * @param {string} [mobilePhoneNumber] 
     * @param {Array<string>} [mobilePhoneNumber2] 
     * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
     * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {string} [dateOfBirthBefore] 
     * @param {string} [dateOfBirthStrictlyBefore] 
     * @param {string} [dateOfBirthAfter] 
     * @param {string} [dateOfBirthStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
     * @summary Unregister a Persona (Your customer)
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieves a Persona resource.
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
     * @summary Updates the Persona resource.
     * @param {string} id Persona identifier
     * @param {PersonaUpdate} personaUpdate The updated Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
     * @summary Register a Persona (Your customer)
     * @param {PersonaWrite} personaWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasPost(personaWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}


/**
 * SafeCheckoutApi - axios parameter creator
 * @export
 */
export const SafeCheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Search amongst Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {string} [unitPrice] 
         * @param {Array<string>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {ApiOffersGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection: async (page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, status?: ApiOffersGetCollectionStatusEnum, shippingAllowed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (publicUrl2) {
                localVarQueryParameter['publicUrl[]'] = publicUrl2;
            }

            if (unitPrice !== undefined) {
                localVarQueryParameter['unitPrice'] = unitPrice;
            }

            if (unitPrice2) {
                localVarQueryParameter['unitPrice[]'] = unitPrice2;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (itemCount2) {
                localVarQueryParameter['itemCount[]'] = itemCount2;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (offerMetadata) {
                localVarQueryParameter['offer.metadata[]'] = offerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (sellerMetadata) {
                localVarQueryParameter['seller.metadata[]'] = sellerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (nature !== undefined) {
                localVarQueryParameter['nature'] = nature;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (shippingAllowed !== undefined) {
                localVarQueryParameter['shippingAllowed'] = shippingAllowed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a public listening Offer linked to a specific Seller
         * @summary Create a public link for Offer
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost: async (offerIndependentWrite: OfferIndependentWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerIndependentWrite' is not null or undefined
            assertParamExists('apiOffersPost', 'offerIndependentWrite', offerIndependentWrite)
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE", "PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a specific Offer as non longer active
         * @summary Disable existing Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidDelete: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidDelete', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Offer resource.
         * @summary Fetch a Offer details
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidGet', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your existing Offer and reuse existing generated link
         * @summary Update existing Offer
         * @param {string} ulid Offer identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidPatch: async (ulid: string, offerUpdate: OfferUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidPatch', 'ulid', ulid)
            // verify required parameter 'offerUpdate' is not null or undefined
            assertParamExists('apiOffersUlidPatch', 'offerUpdate', offerUpdate)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'id', id)
            const localVarPath = `/offers/{ulid}/medias/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a public listening Offer linked to a specific User
         * @summary Issue an Offer as User
         * @param {number} id User identifier
         * @param {OfferSoloWrite} offerSoloWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdoffersPost: async (id: number, offerSoloWrite: OfferSoloWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdoffersPost', 'id', id)
            // verify required parameter 'offerSoloWrite' is not null or undefined
            assertParamExists('apiUsersIdoffersPost', 'offerSoloWrite', offerSoloWrite)
            const localVarPath = `/users/{id}/offers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerSoloWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafeCheckoutApi - functional programming interface
 * @export
 */
export const SafeCheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SafeCheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Search amongst Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {string} [unitPrice] 
         * @param {Array<string>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {ApiOffersGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, status?: ApiOffersGetCollectionStatusEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, sellerMetadata, nature, condition, status, shippingAllowed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a public listening Offer linked to a specific Seller
         * @summary Create a public link for Offer
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersPost(offerIndependentWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Make a specific Offer as non longer active
         * @summary Disable existing Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidDelete(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidDelete(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Offer resource.
         * @summary Fetch a Offer details
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidGet(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update your existing Offer and reuse existing generated link
         * @summary Update existing Offer
         * @param {string} ulid Offer identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidPatch(ulid: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidPatch(ulid, offerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasIdDelete(ulid, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidmediasIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidmediasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a public listening Offer linked to a specific User
         * @summary Issue an Offer as User
         * @param {number} id User identifier
         * @param {OfferSoloWrite} offerSoloWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdoffersPost(id: number, offerSoloWrite: OfferSoloWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdoffersPost(id, offerSoloWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiUsersIdoffersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SafeCheckoutApi - factory interface
 * @export
 */
export const SafeCheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SafeCheckoutApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Search amongst Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {string} [unitPrice] 
         * @param {Array<string>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {ApiOffersGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, status?: ApiOffersGetCollectionStatusEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<OfferCollectionRead>> {
            return localVarFp.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, sellerMetadata, nature, condition, status, shippingAllowed, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a public listening Offer linked to a specific Seller
         * @summary Create a public link for Offer
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiOffersPost(offerIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Make a specific Offer as non longer active
         * @summary Disable existing Offer
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidDelete(ulid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOffersUlidDelete(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Offer resource.
         * @summary Fetch a Offer details
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig): AxiosPromise<OfferRead> {
            return localVarFp.apiOffersUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your existing Offer and reuse existing generated link
         * @summary Update existing Offer
         * @param {string} ulid Offer identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidPatch(ulid: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiOffersUlidPatch(ulid, offerUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a public listening Offer linked to a specific User
         * @summary Issue an Offer as User
         * @param {number} id User identifier
         * @param {OfferSoloWrite} offerSoloWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdoffersPost(id: number, offerSoloWrite: OfferSoloWrite, options?: RawAxiosRequestConfig): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiUsersIdoffersPost(id, offerSoloWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafeCheckoutApi - object-oriented interface
 * @export
 * @class SafeCheckoutApi
 * @extends {BaseAPI}
 */
export class SafeCheckoutApi extends BaseAPI {
    /**
     * Retrieves the collection of Offer resources.
     * @summary Search amongst Offers
     * @param {number} [page] The collection page number
     * @param {string} [title] 
     * @param {string} [publicUrl] 
     * @param {Array<string>} [publicUrl2] 
     * @param {string} [unitPrice] 
     * @param {Array<string>} [unitPrice2] 
     * @param {number} [itemCount] 
     * @param {Array<number>} [itemCount2] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
     * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
     * @param {ApiOffersGetCollectionStatusEnum} [status] Filter on a limited subset of status
     * @param {boolean} [shippingAllowed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, status?: ApiOffersGetCollectionStatusEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, sellerMetadata, nature, condition, status, shippingAllowed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a public listening Offer linked to a specific Seller
     * @summary Create a public link for Offer
     * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersPost(offerIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make a specific Offer as non longer active
     * @summary Disable existing Offer
     * @param {string} ulid Offer identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidDelete(ulid: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidDelete(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Offer resource.
     * @summary Fetch a Offer details
     * @param {string} ulid Offer identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your existing Offer and reuse existing generated link
     * @summary Update existing Offer
     * @param {string} ulid Offer identifier
     * @param {OfferUpdate} offerUpdate The updated Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidPatch(ulid: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidPatch(ulid, offerUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Removes the Media resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a public listening Offer linked to a specific User
     * @summary Issue an Offer as User
     * @param {number} id User identifier
     * @param {OfferSoloWrite} offerSoloWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiUsersIdoffersPost(id: number, offerSoloWrite: OfferSoloWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiUsersIdoffersPost(id, offerSoloWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}


/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a Quote resource.
         * @summary Retrieve a Quote
         * @param {string} id Quote identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuotesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiQuotesIdGet', 'id', id)
            const localVarPath = `/quotes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Quote resource.
         * @summary Update a Quote prior to issuing a Transaction
         * @param {string} id Quote identifier
         * @param {QuoteUpdate} quoteUpdate The updated Quote resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuotesIdPatch: async (id: string, quoteUpdate: QuoteUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiQuotesIdPatch', 'id', id)
            // verify required parameter 'quoteUpdate' is not null or undefined
            assertParamExists('apiQuotesIdPatch', 'quoteUpdate', quoteUpdate)
            const localVarPath = `/quotes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quoteUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Quote resource.
         * @summary Create a Quote prior to issuing a Transaction
         * @param {QuoteWrite} quoteWrite The new Quote resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuotesPost: async (quoteWrite: QuoteWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quoteWrite' is not null or undefined
            assertParamExists('apiQuotesPost', 'quoteWrite', quoteWrite)
            const localVarPath = `/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quoteWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of Transaction paginated
         * @summary List all Transaction
         * @param {number} [page] The collection page number
         * @param {ApiTransactionsGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGetCollection: async (page?: number, orderCreatedAt?: ApiTransactionsGetCollectionOrderCreatedAtEnum, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiTransactionsGetCollectionStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (orderStatus !== undefined) {
                localVarQueryParameter['order[status]'] = orderStatus;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Transaction for Preauthorization
         * @summary Initialize a new Transaction
         * @param {TransactionWrite} transactionWrite The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsPost: async (transactionWrite: TransactionWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionWrite' is not null or undefined
            assertParamExists('apiTransactionsPost', 'transactionWrite', transactionWrite)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Transaction by ID
         * @summary Get a Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidGet', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make decision upon a Transaction in order to make it evolve
         * @summary Interact with a Transaction
         * @param {string} ulid Transaction identifier
         * @param {TransactionUpdate} transactionUpdate The updated Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidPatch: async (ulid: string, transactionUpdate: TransactionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidPatch', 'ulid', ulid)
            // verify required parameter 'transactionUpdate' is not null or undefined
            assertParamExists('apiTransactionsUlidPatch', 'transactionUpdate', transactionUpdate)
            const localVarPath = `/transactions/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a Quote resource.
         * @summary Retrieve a Quote
         * @param {string} id Quote identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuotesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuotesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiQuotesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Quote resource.
         * @summary Update a Quote prior to issuing a Transaction
         * @param {string} id Quote identifier
         * @param {QuoteUpdate} quoteUpdate The updated Quote resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuotesIdPatch(id: string, quoteUpdate: QuoteUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuotesIdPatch(id, quoteUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiQuotesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Quote resource.
         * @summary Create a Quote prior to issuing a Transaction
         * @param {QuoteWrite} quoteWrite The new Quote resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiQuotesPost(quoteWrite: QuoteWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuoteRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiQuotesPost(quoteWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiQuotesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of Transaction paginated
         * @summary List all Transaction
         * @param {number} [page] The collection page number
         * @param {ApiTransactionsGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsGetCollection(page?: number, orderCreatedAt?: ApiTransactionsGetCollectionOrderCreatedAtEnum, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiTransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsGetCollection(page, orderCreatedAt, orderStatus, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new Transaction for Preauthorization
         * @summary Initialize a new Transaction
         * @param {TransactionWrite} transactionWrite The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsPost(transactionWrite: TransactionWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsPost(transactionWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single Transaction by ID
         * @summary Get a Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidGet(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsUlidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Make decision upon a Transaction in order to make it evolve
         * @summary Interact with a Transaction
         * @param {string} ulid Transaction identifier
         * @param {TransactionUpdate} transactionUpdate The updated Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidPatch(ulid: string, transactionUpdate: TransactionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidPatch(ulid, transactionUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.apiTransactionsUlidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * Retrieves a Quote resource.
         * @summary Retrieve a Quote
         * @param {string} id Quote identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuotesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<QuoteRead> {
            return localVarFp.apiQuotesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Quote resource.
         * @summary Update a Quote prior to issuing a Transaction
         * @param {string} id Quote identifier
         * @param {QuoteUpdate} quoteUpdate The updated Quote resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuotesIdPatch(id: string, quoteUpdate: QuoteUpdate, options?: RawAxiosRequestConfig): AxiosPromise<QuoteRead> {
            return localVarFp.apiQuotesIdPatch(id, quoteUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Quote resource.
         * @summary Create a Quote prior to issuing a Transaction
         * @param {QuoteWrite} quoteWrite The new Quote resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiQuotesPost(quoteWrite: QuoteWrite, options?: RawAxiosRequestConfig): AxiosPromise<QuoteRead> {
            return localVarFp.apiQuotesPost(quoteWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of Transaction paginated
         * @summary List all Transaction
         * @param {number} [page] The collection page number
         * @param {ApiTransactionsGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsGetCollection(page?: number, orderCreatedAt?: ApiTransactionsGetCollectionOrderCreatedAtEnum, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiTransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionCollectionRead>> {
            return localVarFp.apiTransactionsGetCollection(page, orderCreatedAt, orderStatus, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Transaction for Preauthorization
         * @summary Initialize a new Transaction
         * @param {TransactionWrite} transactionWrite The new Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsPost(transactionWrite: TransactionWrite, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRead> {
            return localVarFp.apiTransactionsPost(transactionWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Transaction by ID
         * @summary Get a Transaction
         * @param {string} ulid Transaction identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidGet(ulid: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRead> {
            return localVarFp.apiTransactionsUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Make decision upon a Transaction in order to make it evolve
         * @summary Interact with a Transaction
         * @param {string} ulid Transaction identifier
         * @param {TransactionUpdate} transactionUpdate The updated Transaction resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidPatch(ulid: string, transactionUpdate: TransactionUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRead> {
            return localVarFp.apiTransactionsUlidPatch(ulid, transactionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * Retrieves a Quote resource.
     * @summary Retrieve a Quote
     * @param {string} id Quote identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiQuotesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiQuotesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Quote resource.
     * @summary Update a Quote prior to issuing a Transaction
     * @param {string} id Quote identifier
     * @param {QuoteUpdate} quoteUpdate The updated Quote resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiQuotesIdPatch(id: string, quoteUpdate: QuoteUpdate, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiQuotesIdPatch(id, quoteUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Quote resource.
     * @summary Create a Quote prior to issuing a Transaction
     * @param {QuoteWrite} quoteWrite The new Quote resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiQuotesPost(quoteWrite: QuoteWrite, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiQuotesPost(quoteWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of Transaction paginated
     * @summary List all Transaction
     * @param {number} [page] The collection page number
     * @param {ApiTransactionsGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {ApiTransactionsGetCollectionOrderStatusEnum} [orderStatus] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {ApiTransactionsGetCollectionStatusEnum} [status] Filter on a limited subset of status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsGetCollection(page?: number, orderCreatedAt?: ApiTransactionsGetCollectionOrderCreatedAtEnum, orderStatus?: ApiTransactionsGetCollectionOrderStatusEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, status?: ApiTransactionsGetCollectionStatusEnum, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsGetCollection(page, orderCreatedAt, orderStatus, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Transaction for Preauthorization
     * @summary Initialize a new Transaction
     * @param {TransactionWrite} transactionWrite The new Transaction resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsPost(transactionWrite: TransactionWrite, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsPost(transactionWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Transaction by ID
     * @summary Get a Transaction
     * @param {string} ulid Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsUlidGet(ulid: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Make decision upon a Transaction in order to make it evolve
     * @summary Interact with a Transaction
     * @param {string} ulid Transaction identifier
     * @param {TransactionUpdate} transactionUpdate The updated Transaction resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public apiTransactionsUlidPatch(ulid: string, transactionUpdate: TransactionUpdate, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).apiTransactionsUlidPatch(ulid, transactionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiTransactionsGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiTransactionsGetCollectionOrderStatusEnum {
    Asc = 'asc',
    Desc = 'desc'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiTransactionsGetCollectionStatusEnum {
    Created = 'CREATED',
    Authorized = 'AUTHORIZED',
    Refused = 'REFUSED',
    Accepted = 'ACCEPTED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Blocked = 'BLOCKED',
    Delivered = 'DELIVERED',
    Completed = 'COMPLETED',
    Disputed = 'DISPUTED',
    Cancelled = 'CANCELLED'
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the BankAccount resource.
         * @summary Removes the BankAccount resource.
         * @param {string} id BankAccount identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBankAccountsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBankAccountsIdDelete', 'id', id)
            const localVarPath = `/bank-accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a BankAccount resource.
         * @summary Retrieves a BankAccount resource.
         * @param {string} id BankAccount identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBankAccountsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBankAccountsIdGet', 'id', id)
            const localVarPath = `/bank-accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a BankAccount resource.
         * @summary Creates a BankAccount resource.
         * @param {BankAccountWrite} bankAccountWrite The new BankAccount resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBankAccountsPost: async (bankAccountWrite: BankAccountWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankAccountWrite' is not null or undefined
            assertParamExists('apiBankAccountsPost', 'bankAccountWrite', bankAccountWrite)
            const localVarPath = `/bank-accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankAccountWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Card resources.
         * @summary Retrieves the collection of Card resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Card resource.
         * @summary Removes the Card resource.
         * @param {string} id Card identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCardsIdDelete', 'id', id)
            const localVarPath = `/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Card resource.
         * @summary Retrieves a Card resource.
         * @param {string} id Card identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCardsIdGet', 'id', id)
            const localVarPath = `/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Card resource.
         * @summary Push back the tokenization output from the external provider
         * @param {string} id Card identifier
         * @param {CardUpdate} cardUpdate The updated Card resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsIdPatch: async (id: string, cardUpdate: CardUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCardsIdPatch', 'id', id)
            // verify required parameter 'cardUpdate' is not null or undefined
            assertParamExists('apiCardsIdPatch', 'cardUpdate', cardUpdate)
            const localVarPath = `/cards/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Card resource.
         * @summary Creates a Card resource.
         * @param {CardWrite} cardWrite The new Card resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsPost: async (cardWrite: CardWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardWrite' is not null or undefined
            assertParamExists('apiCardsPost', 'cardWrite', cardWrite)
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cardWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of CashOut resources.
         * @summary Retrieves the collection of CashOut resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCashOutsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cash-outs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a CashOut resource.
         * @summary Retrieves a CashOut resource.
         * @param {string} id CashOut identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCashOutsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCashOutsIdGet', 'id', id)
            const localVarPath = `/cash-outs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a CashOut resource.
         * @summary Withdraw the full amount available in the user wallet to set bank account
         * @param {CashoutCashOutWrite} cashoutCashOutWrite The new CashOut resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCashOutsPost: async (cashoutCashOutWrite: CashoutCashOutWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cashoutCashOutWrite' is not null or undefined
            assertParamExists('apiCashOutsPost', 'cashoutCashOutWrite', cashoutCashOutWrite)
            const localVarPath = `/cash-outs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cashoutCashOutWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of ProofOfIdentity resources.
         * @summary List all submitted PoI
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/proof-of-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a ProofOfIdentity resource.
         * @summary Retrieve a specific PoI
         * @param {string} id ProofOfIdentity identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProofOfIdentitiesIdGet', 'id', id)
            const localVarPath = `/proof-of-identities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the ProofOfIdentity resource.
         * @summary Upload the document for your PoI slot
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesIdPatch: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiProofOfIdentitiesIdPatch', 'id', id)
            const localVarPath = `/proof-of-identities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a ProofOfIdentity resource.
         * @summary Submit a slot for a PoI
         * @param {ProofOfIdentityWrite} proofOfIdentityWrite The new ProofOfIdentity resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesPost: async (proofOfIdentityWrite: ProofOfIdentityWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'proofOfIdentityWrite' is not null or undefined
            assertParamExists('apiProofOfIdentitiesPost', 'proofOfIdentityWrite', proofOfIdentityWrite)
            const localVarPath = `/proof-of-identities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proofOfIdentityWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Internal-use only, protected by a captcha. User first-enrollment
         * @summary Customer onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost: async (userWrite: UserWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWrite' is not null or undefined
            assertParamExists('apiRegisterPost', 'userWrite', userWrite)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Update your profile
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch: async (id: string, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdavatarDelete', 'id', id)
            const localVarPath = `/users/{id}/avatar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdavatarPost', 'id', id)
            const localVarPath = `/users/{id}/avatar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailPatch: async (id: string, userUserEmailUpdate: UserUserEmailUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailPatch', 'id', id)
            // verify required parameter 'userUserEmailUpdate' is not null or undefined
            assertParamExists('apiUsersIdemailPatch', 'userUserEmailUpdate', userUserEmailUpdate)
            const localVarPath = `/users/{id}/email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUserEmailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch: async (id: string, userEmailValidationWrite: UserEmailValidationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'id', id)
            // verify required parameter 'userEmailValidationWrite' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'userEmailValidationWrite', userEmailValidationWrite)
            const localVarPath = `/users/{id}/email-validation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEmailValidationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Change your password
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdpasswordPatch: async (id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdpasswordPatch', 'id', id)
            // verify required parameter 'userUserPasswordUpdate' is not null or undefined
            assertParamExists('apiUsersIdpasswordPatch', 'userUserPasswordUpdate', userUserPasswordUpdate)
            const localVarPath = `/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUserPasswordUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Setup an additional authentication factor
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpSetupPatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdtotpSetupPatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIdtotpSetupPatch', 'body', body)
            const localVarPath = `/users/{id}/totp-setup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Disable the second authentication factor
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpTogglePatch: async (id: string, userTotpToggleWrite: UserTotpToggleWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdtotpTogglePatch', 'id', id)
            // verify required parameter 'userTotpToggleWrite' is not null or undefined
            assertParamExists('apiUsersIdtotpTogglePatch', 'userTotpToggleWrite', userTotpToggleWrite)
            const localVarPath = `/users/{id}/totp-toggle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTotpToggleWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost: async (userJwtWrite?: UserJwtWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userJwtWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the BankAccount resource.
         * @summary Removes the BankAccount resource.
         * @param {string} id BankAccount identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBankAccountsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBankAccountsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiBankAccountsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a BankAccount resource.
         * @summary Retrieves a BankAccount resource.
         * @param {string} id BankAccount identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBankAccountsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBankAccountsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiBankAccountsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a BankAccount resource.
         * @summary Creates a BankAccount resource.
         * @param {BankAccountWrite} bankAccountWrite The new BankAccount resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBankAccountsPost(bankAccountWrite: BankAccountWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankAccountRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBankAccountsPost(bankAccountWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiBankAccountsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Card resources.
         * @summary Retrieves the collection of Card resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCardsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CardCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCardsGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCardsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Card resource.
         * @summary Removes the Card resource.
         * @param {string} id Card identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCardsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCardsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCardsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Card resource.
         * @summary Retrieves a Card resource.
         * @param {string} id Card identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCardsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCardsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCardsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Card resource.
         * @summary Push back the tokenization output from the external provider
         * @param {string} id Card identifier
         * @param {CardUpdate} cardUpdate The updated Card resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCardsIdPatch(id: string, cardUpdate: CardUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCardsIdPatch(id, cardUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCardsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Card resource.
         * @summary Creates a Card resource.
         * @param {CardWrite} cardWrite The new Card resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCardsPost(cardWrite: CardWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCardsPost(cardWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCardsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of CashOut resources.
         * @summary Retrieves the collection of CashOut resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCashOutsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CashoutCashOutCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCashOutsGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCashOutsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a CashOut resource.
         * @summary Retrieves a CashOut resource.
         * @param {string} id CashOut identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCashOutsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutCashOutRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCashOutsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCashOutsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a CashOut resource.
         * @summary Withdraw the full amount available in the user wallet to set bank account
         * @param {CashoutCashOutWrite} cashoutCashOutWrite The new CashOut resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCashOutsPost(cashoutCashOutWrite: CashoutCashOutWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutCashOutRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCashOutsPost(cashoutCashOutWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiCashOutsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuthenticatedRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of ProofOfIdentity resources.
         * @summary List all submitted PoI
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProofOfIdentitiesGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProofOfIdentityCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProofOfIdentitiesGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiProofOfIdentitiesGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a ProofOfIdentity resource.
         * @summary Retrieve a specific PoI
         * @param {string} id ProofOfIdentity identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProofOfIdentitiesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProofOfIdentityRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProofOfIdentitiesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiProofOfIdentitiesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the ProofOfIdentity resource.
         * @summary Upload the document for your PoI slot
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProofOfIdentitiesIdPatch(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProofOfIdentityRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProofOfIdentitiesIdPatch(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiProofOfIdentitiesIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a ProofOfIdentity resource.
         * @summary Submit a slot for a PoI
         * @param {ProofOfIdentityWrite} proofOfIdentityWrite The new ProofOfIdentity resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiProofOfIdentitiesPost(proofOfIdentityWrite: ProofOfIdentityWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProofOfIdentityRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiProofOfIdentitiesPost(proofOfIdentityWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiProofOfIdentitiesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Internal-use only, protected by a captcha. User first-enrollment
         * @summary Customer onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRegisterPost(userWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Update your profile
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdPatch(id, userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdavatarDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdavatarDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdavatarPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdavatarPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailPatch(id, userUserEmailUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdemailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdemailValidationPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Change your password
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdpasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Setup an additional authentication factor
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTotpSetupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdtotpSetupPatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdtotpSetupPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Disable the second authentication factor
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdtotpTogglePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJwtCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationPost(userJwtWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.authenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Removes the BankAccount resource.
         * @summary Removes the BankAccount resource.
         * @param {string} id BankAccount identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBankAccountsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiBankAccountsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a BankAccount resource.
         * @summary Retrieves a BankAccount resource.
         * @param {string} id BankAccount identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBankAccountsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BankAccountRead> {
            return localVarFp.apiBankAccountsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a BankAccount resource.
         * @summary Creates a BankAccount resource.
         * @param {BankAccountWrite} bankAccountWrite The new BankAccount resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBankAccountsPost(bankAccountWrite: BankAccountWrite, options?: RawAxiosRequestConfig): AxiosPromise<BankAccountRead> {
            return localVarFp.apiBankAccountsPost(bankAccountWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Card resources.
         * @summary Retrieves the collection of Card resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsGetCollection(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CardCollectionRead>> {
            return localVarFp.apiCardsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Card resource.
         * @summary Removes the Card resource.
         * @param {string} id Card identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiCardsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Card resource.
         * @summary Retrieves a Card resource.
         * @param {string} id Card identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CardRead> {
            return localVarFp.apiCardsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Card resource.
         * @summary Push back the tokenization output from the external provider
         * @param {string} id Card identifier
         * @param {CardUpdate} cardUpdate The updated Card resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsIdPatch(id: string, cardUpdate: CardUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CardRead> {
            return localVarFp.apiCardsIdPatch(id, cardUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Card resource.
         * @summary Creates a Card resource.
         * @param {CardWrite} cardWrite The new Card resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCardsPost(cardWrite: CardWrite, options?: RawAxiosRequestConfig): AxiosPromise<CardRead> {
            return localVarFp.apiCardsPost(cardWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of CashOut resources.
         * @summary Retrieves the collection of CashOut resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCashOutsGetCollection(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CashoutCashOutCollectionRead>> {
            return localVarFp.apiCashOutsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a CashOut resource.
         * @summary Retrieves a CashOut resource.
         * @param {string} id CashOut identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCashOutsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CashoutCashOutRead> {
            return localVarFp.apiCashOutsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a CashOut resource.
         * @summary Withdraw the full amount available in the user wallet to set bank account
         * @param {CashoutCashOutWrite} cashoutCashOutWrite The new CashOut resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCashOutsPost(cashoutCashOutWrite: CashoutCashOutWrite, options?: RawAxiosRequestConfig): AxiosPromise<CashoutCashOutRead> {
            return localVarFp.apiCashOutsPost(cashoutCashOutWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet(options?: RawAxiosRequestConfig): AxiosPromise<UserAuthenticatedRead> {
            return localVarFp.apiMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of ProofOfIdentity resources.
         * @summary List all submitted PoI
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesGetCollection(page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProofOfIdentityCollectionRead>> {
            return localVarFp.apiProofOfIdentitiesGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a ProofOfIdentity resource.
         * @summary Retrieve a specific PoI
         * @param {string} id ProofOfIdentity identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ProofOfIdentityRead> {
            return localVarFp.apiProofOfIdentitiesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the ProofOfIdentity resource.
         * @summary Upload the document for your PoI slot
         * @param {number} id 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesIdPatch(id: number, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<ProofOfIdentityRead> {
            return localVarFp.apiProofOfIdentitiesIdPatch(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a ProofOfIdentity resource.
         * @summary Submit a slot for a PoI
         * @param {ProofOfIdentityWrite} proofOfIdentityWrite The new ProofOfIdentity resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiProofOfIdentitiesPost(proofOfIdentityWrite: ProofOfIdentityWrite, options?: RawAxiosRequestConfig): AxiosPromise<ProofOfIdentityRead> {
            return localVarFp.apiProofOfIdentitiesPost(proofOfIdentityWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Internal-use only, protected by a captcha. User first-enrollment
         * @summary Customer onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiRegisterPost(userWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Update your profile
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdPatch(id, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiUsersIdavatarDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<MediaRead> {
            return localVarFp.apiUsersIdavatarPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserUserRead> {
            return localVarFp.apiUsersIdemailPatch(id, userUserEmailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Change your password
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig): AxiosPromise<UserUserRead> {
            return localVarFp.apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Setup an additional authentication factor
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<UserTotpSetupRead> {
            return localVarFp.apiUsersIdtotpSetupPatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Disable the second authentication factor
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig): AxiosPromise<UserJwtCreated> {
            return localVarFp.authenticationPost(userJwtWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Removes the BankAccount resource.
     * @summary Removes the BankAccount resource.
     * @param {string} id BankAccount identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiBankAccountsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiBankAccountsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a BankAccount resource.
     * @summary Retrieves a BankAccount resource.
     * @param {string} id BankAccount identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiBankAccountsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiBankAccountsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a BankAccount resource.
     * @summary Creates a BankAccount resource.
     * @param {BankAccountWrite} bankAccountWrite The new BankAccount resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiBankAccountsPost(bankAccountWrite: BankAccountWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiBankAccountsPost(bankAccountWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Card resources.
     * @summary Retrieves the collection of Card resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCardsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCardsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Card resource.
     * @summary Removes the Card resource.
     * @param {string} id Card identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCardsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCardsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Card resource.
     * @summary Retrieves a Card resource.
     * @param {string} id Card identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCardsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCardsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Card resource.
     * @summary Push back the tokenization output from the external provider
     * @param {string} id Card identifier
     * @param {CardUpdate} cardUpdate The updated Card resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCardsIdPatch(id: string, cardUpdate: CardUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCardsIdPatch(id, cardUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Card resource.
     * @summary Creates a Card resource.
     * @param {CardWrite} cardWrite The new Card resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCardsPost(cardWrite: CardWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCardsPost(cardWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of CashOut resources.
     * @summary Retrieves the collection of CashOut resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCashOutsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCashOutsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a CashOut resource.
     * @summary Retrieves a CashOut resource.
     * @param {string} id CashOut identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCashOutsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCashOutsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a CashOut resource.
     * @summary Withdraw the full amount available in the user wallet to set bank account
     * @param {CashoutCashOutWrite} cashoutCashOutWrite The new CashOut resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiCashOutsPost(cashoutCashOutWrite: CashoutCashOutWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiCashOutsPost(cashoutCashOutWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of ProofOfIdentity resources.
     * @summary List all submitted PoI
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiProofOfIdentitiesGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiProofOfIdentitiesGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a ProofOfIdentity resource.
     * @summary Retrieve a specific PoI
     * @param {string} id ProofOfIdentity identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiProofOfIdentitiesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiProofOfIdentitiesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the ProofOfIdentity resource.
     * @summary Upload the document for your PoI slot
     * @param {number} id 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiProofOfIdentitiesIdPatch(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiProofOfIdentitiesIdPatch(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a ProofOfIdentity resource.
     * @summary Submit a slot for a PoI
     * @param {ProofOfIdentityWrite} proofOfIdentityWrite The new ProofOfIdentity resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiProofOfIdentitiesPost(proofOfIdentityWrite: ProofOfIdentityWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiProofOfIdentitiesPost(proofOfIdentityWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Internal-use only, protected by a captcha. User first-enrollment
     * @summary Customer onboarding
     * @param {UserWrite} userWrite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiRegisterPost(userWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the User resource.
     * @summary Removes the User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Update your profile
     * @param {string} id User identifier
     * @param {UserUpdate} userUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdPatch(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your personal avatar
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdavatarDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your personal avatar
     * @param {number} id User identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdavatarPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Update user email
     * @param {string} id User identifier
     * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailPatch(id, userUserEmailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Validate email ownership
     * @param {string} id User identifier
     * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Change your password
     * @param {string} id User identifier
     * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Setup an additional authentication factor
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdtotpSetupPatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Disable the second authentication factor
     * @param {string} id User identifier
     * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
     * @summary User authentication
     * @param {UserJwtWrite} [userJwtWrite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).authenticationPost(userJwtWrite, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection: async (page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-histories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (event2) {
                localVarQueryParameter['event[]'] = event2;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['objectId'] = objectId;
            }

            if (objectId2) {
                localVarQueryParameter['objectId[]'] = objectId2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdGet', 'id', id)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'body', body)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection: async (page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsIdDelete', 'id', id)
            const localVarPath = `/webhook-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost: async (webhookSubscriptionWrite: WebhookSubscriptionWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookSubscriptionWrite' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsPost', 'webhookSubscriptionWrite', webhookSubscriptionWrite)
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSubscriptionWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookHistoryCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdPut(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookSubscriptionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsGetCollection(page, event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookHistoryCollectionRead>> {
            return localVarFp.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookSubscriptionRead>> {
            return localVarFp.apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscriptionRead> {
            return localVarFp.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Retrieves the collection of WebhookHistory resources.
     * @summary Retrieves the collection of WebhookHistory resources.
     * @param {number} [page] The collection page number
     * @param {string} [event] 
     * @param {Array<string>} [event2] 
     * @param {string} [objectId] 
     * @param {Array<string>} [objectId2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a WebhookHistory resource.
     * @summary Retrieves a WebhookHistory resource.
     * @param {string} id WebhookHistory identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the WebhookHistory resource.
     * @summary Replay a Webhook that ended up in failure
     * @param {string} id WebhookHistory identifier
     * @param {object} body The updated WebhookHistory resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of WebhookSubscription resources.
     * @summary Retrieves the collection of WebhookSubscription resources.
     * @param {number} [page] The collection page number
     * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the WebhookSubscription resource.
     * @summary Removes the WebhookSubscription resource.
     * @param {string} id WebhookSubscription identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a WebhookSubscription resource.
     * @summary Subscribe to Event(s)
     * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiWebhookSubscriptionsGetCollectionEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}


