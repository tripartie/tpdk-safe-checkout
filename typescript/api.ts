/* tslint:disable */
/* eslint-disable */
/**
 * Safe Checkout
 * Simple, yet elegant web interfaces for your convenience. One request away from your first secured C2C transaction.
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: noc@tripartie.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessError
 */
export interface AccessError {
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiClientPostCreationRead
 */
export interface ApiClientPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiClientPostCreationRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ApiClientRead
 */
export interface ApiClientRead {
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientRead
     */
    'scopes'?: Array<ApiClientReadScopesEnum>;
    /**
     * 
     * @type {string}
     * @memberof ApiClientRead
     */
    'name'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientReadScopesEnum {
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH',
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    OrganizationRead = 'ORGANIZATION_READ'
}

/**
 * 
 * @export
 * @interface ApiClientWrite
 */
export interface ApiClientWrite {
    /**
     * 
     * @type {string}
     * @memberof ApiClientWrite
     */
    'referenceName'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiClientWrite
     */
    'desiredScopes'?: Array<ApiClientWriteDesiredScopesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiClientWriteDesiredScopesEnum {
    OfferRead = 'OFFER_READ',
    OfferWrite = 'OFFER_WRITE',
    OrganizationRead = 'ORGANIZATION_READ',
    PersonaRead = 'PERSONA_READ',
    PersonaWrite = 'PERSONA_WRITE',
    PersonaAuth = 'PERSONA_AUTH'
}

/**
 * 
 * @export
 * @interface AuthError
 */
export interface AuthError {
    /**
     * 
     * @type {number}
     * @memberof AuthError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BankAccountUserRead
 */
export interface BankAccountUserRead {
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'bic': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountUserRead
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface EvaluationRead
 */
export interface EvaluationRead {
    /**
     * 
     * @type {number}
     * @memberof EvaluationRead
     */
    'rating': number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvaluationRead
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface EvaluationWrite
 */
export interface EvaluationWrite {
    /**
     * 
     * @type {number}
     * @memberof EvaluationWrite
     */
    'rating': number;
    /**
     * 
     * @type {string}
     * @memberof EvaluationWrite
     */
    'comment'?: string | null;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface InvalidQueryError
 */
export interface InvalidQueryError {
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidQueryError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {number}
     * @memberof Media
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'extension': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'fingerprint': string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'publicUrl': string;
    /**
     * 
     * @type {File}
     * @memberof Media
     */
    'file'?: File | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'b64EncodedTmpFile'?: string | null;
    /**
     * Associated 374x374 pixels small thumbnail
     * @type {string}
     * @memberof Media
     */
    'thumbnail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'original'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Media
     */
    'offers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaRead
 */
export interface MediaRead {
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'publicUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRead
     */
    'thumbnailUrl'?: string | null;
}
/**
 * 
 * @export
 * @interface MediaUserRead
 */
export interface MediaUserRead {
    /**
     * 
     * @type {string}
     * @memberof MediaUserRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface MessageError
 */
export interface MessageError {
    /**
     * 
     * @type {string}
     * @memberof MessageError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * 
     * @type {number}
     * @memberof Metadata
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Metadata
     */
    'value'?: string | null;
}
/**
 * This error can occurs when you reference objects in the query that does not exist.
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface NotificationRead
 */
export interface NotificationRead {
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'type'?: NotificationReadTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationRead
     */
    'seen': boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum NotificationReadTypeEnum {
    DisputeStateUpdate = 'DISPUTE_STATE_UPDATE',
    DisputeReminder = 'DISPUTE_REMINDER',
    MessageSent = 'MESSAGE_SENT',
    DisputeSettlement = 'DISPUTE_SETTLEMENT',
    DisputeArbitrationRequired = 'DISPUTE_ARBITRATION_REQUIRED',
    DisputeResolved = 'DISPUTE_RESOLVED'
}

/**
 * 
 * @export
 * @interface NotificationUpdate
 */
export interface NotificationUpdate {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationUpdate
     */
    'seen': boolean;
}
/**
 * 
 * @export
 * @interface OfferAddressIndependentWrite
 */
export interface OfferAddressIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferAddressIndependentWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferCollectionRead
 */
export interface OfferCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'status': OfferCollectionReadStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'publicUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'seller': string;
    /**
     * Limit the offer to a particular buyer. Useful if the offer was issued from an auction for instance.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'presetBuyer'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'nature': OfferCollectionReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof OfferCollectionRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'condition'?: OfferCollectionReadConditionEnum;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferCollectionRead
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferCollectionRead
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferCollectionRead
     */
    'shippingCarriers'?: Array<OfferCollectionReadShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferCollectionRead
     */
    'iri'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferCollectionReadShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferIndependentWrite
 */
export interface OfferIndependentWrite {
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {OfferPersonaIndependentWrite}
     * @memberof OfferIndependentWrite
     */
    'seller': OfferPersonaIndependentWrite;
    /**
     * 
     * @type {OfferPersonaIndependentWrite}
     * @memberof OfferIndependentWrite
     */
    'presetBuyer'?: OfferPersonaIndependentWrite | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'nature'?: OfferIndependentWriteNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'currencyCode'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'condition'?: OfferIndependentWriteConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof OfferIndependentWrite
     */
    'weightInGram'?: number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Set<string>}
     * @memberof OfferIndependentWrite
     */
    'shippingCarriers'?: Set<OfferIndependentWriteShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferIndependentWrite
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferIndependentWrite
     */
    'canBeSoldSeparately'?: boolean;
    /**
     * 
     * @type {Array<OfferMetadataIndependentWrite>}
     * @memberof OfferIndependentWrite
     */
    'metadata'?: Array<OfferMetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferIndependentWriteShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferMediaRead
 */
export interface OfferMediaRead {
    /**
     * 
     * @type {string}
     * @memberof OfferMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OfferMetadataIndependentWrite
 */
export interface OfferMetadataIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataIndependentWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataIndependentWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferMetadataUpdate
 */
export interface OfferMetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferMetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferOrganizationRead
 */
export interface OfferOrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {OfferMediaRead}
     * @memberof OfferOrganizationRead
     */
    'icon'?: OfferMediaRead | null;
    /**
     * 
     * @type {OfferMediaRead}
     * @memberof OfferOrganizationRead
     */
    'logo'?: OfferMediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof OfferOrganizationRead
     */
    'primaryColor'?: string | null;
}
/**
 * 
 * @export
 * @interface OfferPersonaIndependentWrite
 */
export interface OfferPersonaIndependentWrite {
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'gender': OfferPersonaIndependentWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferPersonaIndependentWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {OfferAddressIndependentWrite}
     * @memberof OfferPersonaIndependentWrite
     */
    'address'?: OfferAddressIndependentWrite | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<OfferMetadataIndependentWrite>}
     * @memberof OfferPersonaIndependentWrite
     */
    'metadata'?: Array<OfferMetadataIndependentWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferPersonaIndependentWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface OfferPostCreationRead
 */
export interface OfferPostCreationRead {
    /**
     * 
     * @type {string}
     * @memberof OfferPostCreationRead
     */
    'ulid'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferPostCreationRead
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferPostCreationRead
     */
    'presetBuyerId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof OfferPostCreationRead
     */
    'sellerId'?: number | null;
}
/**
 * 
 * @export
 * @interface OfferRead
 */
export interface OfferRead {
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'status': OfferReadStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferRead
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferRead
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {OfferOrganizationRead}
     * @memberof OfferRead
     */
    'organization'?: OfferOrganizationRead | null;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'seller': string;
    /**
     * Limit the offer to a particular buyer. Useful if the offer was issued from an auction for instance.
     * @type {string}
     * @memberof OfferRead
     */
    'presetBuyer'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof OfferRead
     */
    'nature': OfferReadNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'condition'?: OfferReadConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof OfferRead
     */
    'weightInGram': number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferRead
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferRead
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof OfferRead
     */
    'shippingCarriers'?: Array<OfferReadShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferRead
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<OfferMediaRead>}
     * @memberof OfferRead
     */
    'medias': Array<OfferMediaRead>;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferRead
     */
    'iri'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferReadStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum OfferReadShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OfferUpdate
 */
export interface OfferUpdate {
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof OfferUpdate
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof OfferUpdate
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OfferUpdate
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'currencyCode'?: string;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'shippingAllowed'?: boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'handDeliveryAllowed'?: boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Set<string>}
     * @memberof OfferUpdate
     */
    'shippingCarriers'?: Set<OfferUpdateShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof OfferUpdate
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof OfferUpdate
     */
    'canBeSoldSeparately'?: boolean;
    /**
     * 
     * @type {Array<OfferMetadataUpdate>}
     * @memberof OfferUpdate
     */
    'metadata'?: Array<OfferMetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum OfferUpdateShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}

/**
 * 
 * @export
 * @interface OrganizationAddressUpdate
 */
export interface OrganizationAddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationAddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationCollectionRead
 */
export interface OrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationCollectionRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {OrganizationMediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'icon'?: OrganizationMediaCollectionRead | null;
    /**
     * 
     * @type {OrganizationMediaCollectionRead}
     * @memberof OrganizationCollectionRead
     */
    'logo'?: OrganizationMediaCollectionRead | null;
}
/**
 * 
 * @export
 * @interface OrganizationMediaCollectionRead
 */
export interface OrganizationMediaCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OrganizationMediaRead
 */
export interface OrganizationMediaRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface OrganizationRead
 */
export interface OrganizationRead {
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {OrganizationMediaRead}
     * @memberof OrganizationRead
     */
    'icon'?: OrganizationMediaRead | null;
    /**
     * 
     * @type {OrganizationMediaRead}
     * @memberof OrganizationRead
     */
    'logo'?: OrganizationMediaRead | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationRead
     */
    'primaryColor'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationUpdate
 */
export interface OrganizationUpdate {
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'vatNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'commercialRegistryNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'websiteUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'customBaseUrl'?: string | null;
    /**
     * 
     * @type {OrganizationAddressUpdate}
     * @memberof OrganizationUpdate
     */
    'billingAddress'?: OrganizationAddressUpdate | null;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUpdate
     */
    'primaryColor'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationUserRead
 */
export interface OrganizationUserRead {
    /**
     * 
     * @type {number}
     * @memberof OrganizationUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationUserRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationUserRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof OrganizationUserRead
     */
    'icon'?: MediaUserRead | null;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof OrganizationUserRead
     */
    'logo'?: MediaUserRead | null;
}
/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'carrier': ParcelCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'identifier': string;
    /**
     * 
     * @type {number}
     * @memberof Parcel
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Parcel
     */
    'refundable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'currency'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'status'?: ParcelStatusEnum | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'transaction'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Parcel
     */
    'updatedAt'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelStatusEnum {
    Created = 'CREATED',
    Shipped = 'SHIPPED',
    InTransit = 'IN_TRANSIT',
    Delivered = 'DELIVERED',
    Error = 'ERROR',
    Accepted = 'ACCEPTED',
    Refused = 'REFUSED',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface ParcelWrite
 */
export interface ParcelWrite {
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'carrier'?: ParcelWriteCarrierEnum;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'identifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof ParcelWrite
     */
    'price'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ParcelWrite
     */
    'refundable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ParcelWrite
     */
    'currency'?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelWriteCarrierEnum {
    SwissPost = 'SwissPost',
    MondialRelay = 'MondialRelay',
    Colissimo = 'Colissimo',
    Dhl = 'Dhl',
    Chronopost = 'Chronopost',
    ColisPrive = 'ColisPrive',
    Dpd = 'Dpd',
    Ups = 'Ups',
    FedEx = 'FedEx',
    RelaisColis = 'RelaisColis'
}

/**
 * 
 * @export
 * @interface Persona
 */
export interface Persona {
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'gender'?: PersonaGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof Persona
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Persona
     */
    'address'?: Address | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<Metadata>}
     * @memberof Persona
     */
    'metadata'?: Array<Metadata>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'offers': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Persona
     */
    'purchases': Array<string>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Persona
     */
    'views': Array<View>;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Persona
     */
    'ownedBy'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof Persona
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Persona
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaAddressRead
 */
export interface PersonaAddressRead {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'gateOrPortalOrInboxCode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressRead
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAddressUpdate
 */
export interface PersonaAddressUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressUpdate
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaAddressWrite
 */
export interface PersonaAddressWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'companyName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'countryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'zipCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'cityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'firstLine'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'secondLine'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'buildingName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'buildingFloor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaAddressWrite
     */
    'gateOrPortalOrInboxCode'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaCollectionRead
 */
export interface PersonaCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaCollectionRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaCollectionRead
     */
    'purchaseCount'?: number;
}
/**
 * 
 * @export
 * @interface PersonaMetadataRead
 */
export interface PersonaMetadataRead {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataRead
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataRead
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataUpdate
 */
export interface PersonaMetadataUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataUpdate
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataUpdate
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaMetadataWrite
 */
export interface PersonaMetadataWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataWrite
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaMetadataWrite
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface PersonaRead
 */
export interface PersonaRead {
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'gender'?: PersonaReadGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaRead
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressRead}
     * @memberof PersonaRead
     */
    'address'?: PersonaAddressRead | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataRead>}
     * @memberof PersonaRead
     */
    'metadata'?: Array<PersonaMetadataRead>;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonaRead
     */
    'updatedAt'?: string | null;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof PersonaRead
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PersonaRead
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaReadGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaUpdate
 */
export interface PersonaUpdate {
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'gender': PersonaUpdateGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaUpdate
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaUpdate
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressUpdate}
     * @memberof PersonaUpdate
     */
    'address'?: PersonaAddressUpdate | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataUpdate>}
     * @memberof PersonaUpdate
     */
    'metadata'?: Array<PersonaMetadataUpdate>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaUpdateGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface PersonaWrite
 */
export interface PersonaWrite {
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'gender': PersonaWriteGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof PersonaWrite
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonaWrite
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressWrite}
     * @memberof PersonaWrite
     */
    'address'?: PersonaAddressWrite | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataWrite>}
     * @memberof PersonaWrite
     */
    'metadata'?: Array<PersonaMetadataWrite>;
}

/**
    * @export
    * @enum {string}
    */
export enum PersonaWriteGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface RateLimitError
 */
export interface RateLimitError {
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateLimitError
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface UnprocessableEntity
 */
export interface UnprocessableEntity {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntity
     */
    'detail'?: string;
    /**
     * 
     * @type {Array<UnprocessableEntityViolationsInner>}
     * @memberof UnprocessableEntity
     */
    'violations'?: Array<UnprocessableEntityViolationsInner>;
}
/**
 * 
 * @export
 * @interface UnprocessableEntityViolationsInner
 */
export interface UnprocessableEntityViolationsInner {
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'propertyPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnprocessableEntityViolationsInner
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface UserAuthenticatedRead
 */
export interface UserAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserAuthenticatedRead
     */
    'roles': Array<UserAuthenticatedReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'avatar'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'consentMailAds': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'lockdown': boolean;
    /**
     * 
     * @type {UserOrganizationAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'organization'?: UserOrganizationAuthenticatedRead | null;
    /**
     * 
     * @type {UserBankAccountAuthenticatedRead}
     * @memberof UserAuthenticatedRead
     */
    'bankAccount'?: UserBankAccountAuthenticatedRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'identityVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticatedRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserAuthenticatedRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserAuthenticatedReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserBankAccountAuthenticatedRead
 */
export interface UserBankAccountAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'iban': string;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'bic': string;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserBankAccountAuthenticatedRead
     */
    'updatedAt'?: string | null;
}
/**
 * 
 * @export
 * @interface UserCollectionRead
 */
export interface UserCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCollectionRead
     */
    'roles': Array<UserCollectionReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserCollectionRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaCollectionRead}
     * @memberof UserCollectionRead
     */
    'avatar'?: UserMediaCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserOrganizationCollectionRead}
     * @memberof UserCollectionRead
     */
    'organization'?: UserOrganizationCollectionRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserCollectionRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCollectionRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCollectionReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserEmailValidationWrite
 */
export interface UserEmailValidationWrite {
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'plainPassword'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserEmailValidationWrite
     */
    'emailVerificationInput': string | null;
}
/**
 * 
 * @export
 * @interface UserInvite
 */
export interface UserInvite {
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserInvite
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserInvite
     */
    'invitedRole': Array<UserInviteInvitedRoleEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UserInviteInvitedRoleEnum {
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    CustomerService2 = 'ROLE_CUSTOMER_SERVICE',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER'
}

/**
 * 
 * @export
 * @interface UserJwtCreated
 */
export interface UserJwtCreated {
    /**
     * 
     * @type {string}
     * @memberof UserJwtCreated
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UserJwtWrite
 */
export interface UserJwtWrite {
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'captcha'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserJwtWrite
     */
    'totpInput'?: string;
}
/**
 * 
 * @export
 * @interface UserMediaAuthenticatedRead
 */
export interface UserMediaAuthenticatedRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaAuthenticatedRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaCollectionRead
 */
export interface UserMediaCollectionRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaCollectionRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaRead
 */
export interface UserMediaRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserMediaSupportRead
 */
export interface UserMediaSupportRead {
    /**
     * 
     * @type {string}
     * @memberof UserMediaSupportRead
     */
    'publicUrl': string;
}
/**
 * 
 * @export
 * @interface UserOrganizationAuthenticatedRead
 */
export interface UserOrganizationAuthenticatedRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'domainVerified': boolean;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'icon'?: UserMediaAuthenticatedRead | null;
    /**
     * 
     * @type {UserMediaAuthenticatedRead}
     * @memberof UserOrganizationAuthenticatedRead
     */
    'logo'?: UserMediaAuthenticatedRead | null;
}
/**
 * 
 * @export
 * @interface UserOrganizationCollectionRead
 */
export interface UserOrganizationCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationCollectionRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserOrganizationRead
 */
export interface UserOrganizationRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationRead
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserOrganizationRead
     */
    'domainVerified'?: boolean;
    /**
     * 
     * @type {UserMediaRead}
     * @memberof UserOrganizationRead
     */
    'icon'?: UserMediaRead | null;
    /**
     * 
     * @type {UserMediaRead}
     * @memberof UserOrganizationRead
     */
    'logo'?: UserMediaRead | null;
}
/**
 * 
 * @export
 * @interface UserOrganizationSupportRead
 */
export interface UserOrganizationSupportRead {
    /**
     * 
     * @type {number}
     * @memberof UserOrganizationSupportRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrganizationSupportRead
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UserPostRegisterRead
 */
export interface UserPostRegisterRead {
    /**
     * 
     * @type {number}
     * @memberof UserPostRegisterRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPostRegisterRead
     */
    'iri'?: string;
}
/**
 * 
 * @export
 * @interface UserSupportRead
 */
export interface UserSupportRead {
    /**
     * 
     * @type {number}
     * @memberof UserSupportRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSupportRead
     */
    'roles': Array<UserSupportReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSupportRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {UserMediaSupportRead}
     * @memberof UserSupportRead
     */
    'avatar'?: UserMediaSupportRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {UserOrganizationSupportRead}
     * @memberof UserSupportRead
     */
    'organization'?: UserOrganizationSupportRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserSupportRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSupportRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserSupportReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * 
 * @export
 * @interface UserTotpSetupRead
 */
export interface UserTotpSetupRead {
    /**
     * 
     * @type {string}
     * @memberof UserTotpSetupRead
     */
    'totpUri'?: string | null;
}
/**
 * 
 * @export
 * @interface UserTotpToggleWrite
 */
export interface UserTotpToggleWrite {
    /**
     * 
     * @type {boolean}
     * @memberof UserTotpToggleWrite
     */
    'totpEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserTotpToggleWrite
     */
    'totpChallenge': string | null;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'intlPhoneNumber'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'consentMailAds': boolean;
}
/**
 * 
 * @export
 * @interface UserUserEmailUpdate
 */
export interface UserUserEmailUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUserEmailUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUserEmailUpdate
     */
    'plainPassword': string | null;
}
/**
 * 
 * @export
 * @interface UserUserPasswordUpdate
 */
export interface UserUserPasswordUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUserPasswordUpdate
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserPasswordUpdate
     */
    'newPassword': string | null;
}
/**
 * 
 * @export
 * @interface UserUserRead
 */
export interface UserUserRead {
    /**
     * 
     * @type {number}
     * @memberof UserUserRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUserRead
     */
    'roles'?: Array<UserUserReadRolesEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'totpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserUserRead
     */
    'originCountry'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'preferredLanguage'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'lastSuccessfulLogIn'?: string | null;
    /**
     * 
     * @type {MediaUserRead}
     * @memberof UserUserRead
     */
    'avatar'?: MediaUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'consentMailAds'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'lockdown'?: boolean;
    /**
     * 
     * @type {OrganizationUserRead}
     * @memberof UserUserRead
     */
    'organization'?: OrganizationUserRead | null;
    /**
     * 
     * @type {BankAccountUserRead}
     * @memberof UserUserRead
     */
    'bankAccount'?: BankAccountUserRead | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'identityVerifiedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUserRead
     */
    'iri'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'impersonatingOrganization'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUserRead
     */
    'secondAuthFactor'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum UserUserReadRolesEnum {
    OrganizationOwner = 'ROLE_ORGANIZATION_OWNER',
    Admin = 'ROLE_ADMIN',
    Consultant = 'ROLE_CONSULTANT',
    AccountingManager = 'ROLE_ACCOUNTING_MANAGER',
    BillingManager = 'ROLE_BILLING_MANAGER',
    CustomerService = 'ROLE_CUSTOMER_SERVICE',
    PlatformSupport = 'ROLE_PLATFORM_SUPPORT',
    PlatformAdmin = 'ROLE_PLATFORM_ADMIN',
    User = 'ROLE_USER'
}

/**
 * Disable a user account
 * @export
 * @interface UserUserSubscribed
 */
export interface UserUserSubscribed {
    /**
     * 
     * @type {number}
     * @memberof UserUserSubscribed
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUserSubscribed
     */
    'iri'?: string;
}
/**
 * 
 * @export
 * @interface UserWrite
 */
export interface UserWrite {
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'captcha': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'publicName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'roleInCompany'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'birthday'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'plainPassword': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'intlPhoneNumber'?: string | null;
    /**
     * The originating country
     * @type {string}
     * @memberof UserWrite
     */
    'originCountry': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWrite
     */
    'preferredLanguage': string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserWrite
     */
    'consentMailAds'?: boolean;
}
/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'ipAddress': string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'offer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'persona'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'user'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof View
     */
    'hitCount': number;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'namedSource'?: ViewNamedSourceEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ViewNamedSourceEnum {
    Buyer = 'BUYER',
    Platform = 'PLATFORM',
    Seller = 'SELLER',
    Other = 'OTHER'
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'event'?: WebhookEventEnum;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'objectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'iri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'occurredAt'?: string;
    /**
     * 
     * @type {WebhookObject}
     * @memberof Webhook
     */
    'object'?: WebhookObject;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryCollectionRead
 */
export interface WebhookHistoryCollectionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'event': WebhookHistoryCollectionReadEventEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryCollectionRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryCollectionRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryCollectionRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryCollectionReadEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookHistoryRead
 */
export interface WebhookHistoryRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'objectId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'event': WebhookHistoryReadEventEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookHistoryRead
     */
    'normalizedObject'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'responseCode'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'responseBody'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'occurredAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookHistoryRead
     */
    'attemptedAt'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WebhookHistoryRead
     */
    'retryCount': number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookHistoryRead
     */
    'inProgress'?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookHistoryReadEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}

/**
 * 
 * @export
 * @interface WebhookObject
 */
export interface WebhookObject {
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'ulid': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'status': WebhookObjectStatusEnum;
    /**
     * The public URL for your Ad/Offer on your marketplace.
     * @type {string}
     * @memberof WebhookObject
     */
    'publicUrl'?: string | null;
    /**
     * Fill-in that field IF you intend to redirect your customer instead of using a WebView.
     * @type {string}
     * @memberof WebhookObject
     */
    'redirectUrl'?: string | null;
    /**
     * 
     * @type {OfferOrganizationRead}
     * @memberof WebhookObject
     */
    'organization'?: OfferOrganizationRead | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'seller': string;
    /**
     * Limit the offer to a particular buyer. Useful if the offer was issued from an auction for instance.
     * @type {string}
     * @memberof WebhookObject
     */
    'presetBuyer'?: string | null;
    /**
     * This WILL affect the assigned workflow. Choosing service will disable delivery for example. Refer to our technical hub for more information.
     * @type {string}
     * @memberof WebhookObject
     */
    'nature': WebhookObjectNatureEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'unitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'currencyCode': string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'itemCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'condition'?: WebhookObjectConditionEnum;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'weightInGram': number;
    /**
     * That toggle allows the seller to propose shipping for its item. If set in conjunction of shippingCarrier, the label will be automatically generated. Also, it will restrict the carrier to the limited subset defined.
     * @type {boolean}
     * @memberof WebhookObject
     */
    'shippingAllowed': boolean;
    /**
     * Enable both parties to finalize the transaction in person rather than using delivery. A QR Code must be scanned by the seller once the buyer claims the product.
     * @type {boolean}
     * @memberof WebhookObject
     */
    'handDeliveryAllowed': boolean;
    /**
     * If you wish to enable automated shipping label generation through a specific provider, specify it there.
     * @type {Array<string>}
     * @memberof WebhookObject
     */
    'shippingCarriers'?: Array<WebhookObjectShippingCarriersEnum>;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'eanCode'?: string | null;
    /**
     * Set this flag to false to forbid a potential buyer to acquire less than \"itemCount\" item(s)
     * @type {boolean}
     * @memberof WebhookObject
     */
    'canBeSoldSeparately': boolean;
    /**
     * 
     * @type {Array<OfferMediaRead>}
     * @memberof WebhookObject
     */
    'medias': Array<OfferMediaRead>;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'updatedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'iri'?: string;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'gender'?: WebhookObjectGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'dateOfBirth'?: string | null;
    /**
     * That data is used for rendering the frontend application with given language. If not set, will be inferred. Custom codes can be issued for specific requirements.
     * @type {string}
     * @memberof WebhookObject
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookObject
     */
    'mobilePhoneNumber'?: string | null;
    /**
     * 
     * @type {PersonaAddressRead}
     * @memberof WebhookObject
     */
    'address'?: PersonaAddressRead | null;
    /**
     * You can assign different meta to your Persona object for different purposes. eg. Ease searching.
     * @type {Array<PersonaMetadataRead>}
     * @memberof WebhookObject
     */
    'metadata'?: Array<PersonaMetadataRead>;
    /**
     * Issued Offers count owned by a given Persona
     * @type {number}
     * @memberof WebhookObject
     */
    'offerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookObject
     */
    'purchaseCount'?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectStatusEnum {
    Issued = 'issued',
    Active = 'active',
    Fulfilled = 'fulfilled',
    Expired = 'expired'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectShippingCarriersEnum {
    SwissPost = 'SwissPost',
    Colissimo = 'Colissimo',
    MondialRelay = 'MondialRelay'
}
/**
    * @export
    * @enum {string}
    */
export enum WebhookObjectGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionRead
 */
export interface WebhookSubscriptionRead {
    /**
     * 
     * @type {number}
     * @memberof WebhookSubscriptionRead
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'event'?: WebhookSubscriptionReadEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'callbackUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'webhookSecret': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionRead
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionReadEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added',
    Null = 'null'
}

/**
 * 
 * @export
 * @interface WebhookSubscriptionWrite
 */
export interface WebhookSubscriptionWrite {
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'event'?: WebhookSubscriptionWriteEventEnum | null;
    /**
     * 
     * @type {string}
     * @memberof WebhookSubscriptionWrite
     */
    'callbackUrl': string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookSubscriptionWriteEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added',
    Null = 'null'
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch: async (id: string, organizationUpdate: OrganizationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'id', id)
            // verify required parameter 'organizationUpdate' is not null or undefined
            assertParamExists('apiOrganizationsIdPatch', 'organizationUpdate', organizationUpdate)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconDelete', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdiconPost', 'id', id)
            const localVarPath = `/organizations/{id}/icon`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoDelete', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdlogoPost', 'id', id)
            const localVarPath = `/organizations/{id}/logo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrandingApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdPatch(id, organizationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdiconPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdiconPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdlogoPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrandingApi.apiOrganizationsIdlogoPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrandingApiFp(configuration)
    return {
        /**
         * Updates the Organization resource.
         * @summary Update your Organization details, branding or parameters
         * @param {string} id Organization identifier
         * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: any): AxiosPromise<UserOrganizationRead> {
            return localVarFp.apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Icon
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdiconDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization Icon
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdiconPost(id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdiconPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your Organization Logo
         * @param {number} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOrganizationsIdlogoDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your Organization logo
         * @param {number} id Organization identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdlogoPost(id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOrganizationsIdlogoPost(id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * Updates the Organization resource.
     * @summary Update your Organization details, branding or parameters
     * @param {string} id Organization identifier
     * @param {OrganizationUpdate} organizationUpdate The updated Organization resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdPatch(id: string, organizationUpdate: OrganizationUpdate, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdPatch(id, organizationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Icon
     * @param {number} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconDelete(id: number, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization Icon
     * @param {number} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdiconPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdiconPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your Organization Logo
     * @param {number} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoDelete(id: number, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your Organization logo
     * @param {number} id Organization identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public apiOrganizationsIdlogoPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return BrandingApiFp(this.configuration).apiOrganizationsIdlogoPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection: async (id: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/personas/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch: async (personaId: string, id: string, notificationUpdate: NotificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'personaId', personaId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiPersonasPersonaIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/personas/{personaId}/notifications/{id}`
                .replace(`{${"personaId"}}`, encodeURIComponent(String(personaId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection: async (id: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdnotificationsGetCollection', 'id', id)
            const localVarPath = `/users/{id}/notifications`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch: async (userId: string, id: string, notificationUpdate: NotificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'id', id)
            // verify required parameter 'notificationUpdate' is not null or undefined
            assertParamExists('apiUsersUserIdnotificationsIdPatch', 'notificationUpdate', notificationUpdate)
            const localVarPath = `/users/{userId}/notifications/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdnotificationsGetCollection(id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiPersonasIdnotificationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiPersonasPersonaIdnotificationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdnotificationsGetCollection(id, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiUsersIdnotificationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationApi.apiUsersUserIdnotificationsIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieve pending notifications for Persona
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for Persona
         * @param {string} personaId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Notification resources.
         * @summary Retrieves the collection of Notification resources.
         * @param {string} id Notification identifier
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: any): AxiosPromise<Array<NotificationRead>> {
            return localVarFp.apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Notification resource.
         * @summary Mark as read/unread a notification for User
         * @param {string} userId Notification identifier
         * @param {string} id Notification identifier
         * @param {NotificationUpdate} notificationUpdate The updated Notification resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: any): AxiosPromise<NotificationRead> {
            return localVarFp.apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieve pending notifications for Persona
     * @param {string} id Notification identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for Persona
     * @param {string} personaId Notification identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiPersonasPersonaIdnotificationsIdPatch(personaId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiPersonasPersonaIdnotificationsIdPatch(personaId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Notification resources.
     * @summary Retrieves the collection of Notification resources.
     * @param {string} id Notification identifier
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersIdnotificationsGetCollection(id: string, page?: number, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersIdnotificationsGetCollection(id, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the Notification resource.
     * @summary Mark as read/unread a notification for User
     * @param {string} userId Notification identifier
     * @param {string} id Notification identifier
     * @param {NotificationUpdate} notificationUpdate The updated Notification resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public apiUsersUserIdnotificationsIdPatch(userId: string, id: string, notificationUpdate: NotificationUpdate, options?: RawAxiosRequestConfig) {
        return NotificationApiFp(this.configuration).apiUsersUserIdnotificationsIdPatch(userId, id, notificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection: async (page?: number, itemsPerPage?: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (itemsPerPage !== undefined) {
                localVarQueryParameter['itemsPerPage'] = itemsPerPage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOrganizationsIdGet', 'id', id)
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsGetCollection(page, itemsPerPage, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.apiOrganizationsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOrganizationsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.apiOrganizationsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Organization resources.
         * @summary Retrieves the collection of Organization resources.
         * @param {number} [page] The collection page number
         * @param {number} [itemsPerPage] The number of items per page
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: any): AxiosPromise<Array<OrganizationCollectionRead>> {
            return localVarFp.apiOrganizationsGetCollection(page, itemsPerPage, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Organization resource.
         * @summary Retrieves a Organization resource.
         * @param {string} id Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrganizationsIdGet(id: string, options?: any): AxiosPromise<OrganizationRead> {
            return localVarFp.apiOrganizationsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * Retrieves the collection of Organization resources.
     * @summary Retrieves the collection of Organization resources.
     * @param {number} [page] The collection page number
     * @param {number} [itemsPerPage] The number of items per page
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public apiOrganizationsGetCollection(page?: number, itemsPerPage?: number, name?: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).apiOrganizationsGetCollection(page, itemsPerPage, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Organization resource.
     * @summary Retrieves a Organization resource.
     * @param {string} id Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public apiOrganizationsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).apiOrganizationsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PersonaApi - axios parameter creator
 * @export
 */
export const PersonaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection: async (page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (email2) {
                localVarQueryParameter['email[]'] = email2;
            }

            if (mobilePhoneNumber !== undefined) {
                localVarQueryParameter['mobilePhoneNumber'] = mobilePhoneNumber;
            }

            if (mobilePhoneNumber2) {
                localVarQueryParameter['mobilePhoneNumber[]'] = mobilePhoneNumber2;
            }

            if (gender !== undefined) {
                localVarQueryParameter['gender'] = gender;
            }

            if (orderCreatedAt !== undefined) {
                localVarQueryParameter['order[createdAt]'] = orderCreatedAt;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (dateOfBirthBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[before]'] = dateOfBirthBefore;
            }

            if (dateOfBirthStrictlyBefore !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_before]'] = dateOfBirthStrictlyBefore;
            }

            if (dateOfBirthAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[after]'] = dateOfBirthAfter;
            }

            if (dateOfBirthStrictlyAfter !== undefined) {
                localVarQueryParameter['dateOfBirth[strictly_after]'] = dateOfBirthStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdDelete', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdGet', 'id', id)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch: async (id: string, personaUpdate: PersonaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'id', id)
            // verify required parameter 'personaUpdate' is not null or undefined
            assertParamExists('apiPersonasIdPatch', 'personaUpdate', personaUpdate)
            const localVarPath = `/personas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost: async (personaWrite: PersonaWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaWrite' is not null or undefined
            assertParamExists('apiPersonasPost', 'personaWrite', personaWrite)
            const localVarPath = `/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(personaWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonaApi - functional programming interface
 * @export
 */
export const PersonaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonaApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PersonaCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasIdPatch(id, personaUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPersonasPost(personaWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PersonaApi.apiPersonasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PersonaApi - factory interface
 * @export
 */
export const PersonaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonaApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Persona resources.
         * @summary Retrieves the collection of Persona resources.
         * @param {number} [page] The collection page number
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {Array<string>} [email2] 
         * @param {string} [mobilePhoneNumber] 
         * @param {Array<string>} [mobilePhoneNumber2] 
         * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
         * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {string} [dateOfBirthBefore] 
         * @param {string} [dateOfBirthStrictlyBefore] 
         * @param {string} [dateOfBirthAfter] 
         * @param {string} [dateOfBirthStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: any): AxiosPromise<Array<PersonaCollectionRead>> {
            return localVarFp.apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
         * @summary Unregister a Persona (Your customer)
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPersonasIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Persona resource.
         * @summary Retrieves a Persona resource.
         * @param {string} id Persona identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdGet(id: string, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
         * @summary Updates the Persona resource.
         * @param {string} id Persona identifier
         * @param {PersonaUpdate} personaUpdate The updated Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
         * @summary Register a Persona (Your customer)
         * @param {PersonaWrite} personaWrite The new Persona resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPersonasPost(personaWrite: PersonaWrite, options?: any): AxiosPromise<PersonaRead> {
            return localVarFp.apiPersonasPost(personaWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PersonaApi - object-oriented interface
 * @export
 * @class PersonaApi
 * @extends {BaseAPI}
 */
export class PersonaApi extends BaseAPI {
    /**
     * Retrieves the collection of Persona resources.
     * @summary Retrieves the collection of Persona resources.
     * @param {number} [page] The collection page number
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [email] 
     * @param {Array<string>} [email2] 
     * @param {string} [mobilePhoneNumber] 
     * @param {Array<string>} [mobilePhoneNumber2] 
     * @param {ApiPersonasGetCollectionGenderEnum} [gender] Filter on a limited subset of gender
     * @param {ApiPersonasGetCollectionOrderCreatedAtEnum} [orderCreatedAt] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {string} [dateOfBirthBefore] 
     * @param {string} [dateOfBirthStrictlyBefore] 
     * @param {string} [dateOfBirthAfter] 
     * @param {string} [dateOfBirthStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasGetCollection(page?: number, firstName?: string, lastName?: string, email?: string, email2?: Array<string>, mobilePhoneNumber?: string, mobilePhoneNumber2?: Array<string>, gender?: ApiPersonasGetCollectionGenderEnum, orderCreatedAt?: ApiPersonasGetCollectionOrderCreatedAtEnum, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, dateOfBirthBefore?: string, dateOfBirthStrictlyBefore?: string, dateOfBirthAfter?: string, dateOfBirthStrictlyAfter?: string, metadata?: Array<string>, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasGetCollection(page, firstName, lastName, email, email2, mobilePhoneNumber, mobilePhoneNumber2, gender, orderCreatedAt, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, dateOfBirthBefore, dateOfBirthStrictlyBefore, dateOfBirthAfter, dateOfBirthStrictlyAfter, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You **MAY** unregister (or free the email/phone number) your Persona entry using that endpoint. *Please note that* this operation will fail if that Persona have any ongoing operations.
     * @summary Unregister a Persona (Your customer)
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Persona resource.
     * @summary Retrieves a Persona resource.
     * @param {string} id Persona identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdGet(id: string, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your Persona (eg. your customer/user entry) through that API call. _Beware that updating_ **email** and/or the **mobile phone number** must be done using non reserved values. Otherwise this operation will be rejected.
     * @summary Updates the Persona resource.
     * @param {string} id Persona identifier
     * @param {PersonaUpdate} personaUpdate The updated Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasIdPatch(id: string, personaUpdate: PersonaUpdate, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasIdPatch(id, personaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You should not register your whole database of users, only those who are concerned by a Transaction operation. One Persona entry for your organization can be assigned as a seller or buyer.  **Notes:**   - (i) There is a unique constraint for the mobile phone numbers and email.   - (ii) You will have to issue a DELETE operation on a Persona that withhold a specific phone number or email.   - (iii) You are NOT REQUIRED to provide email OR a mobile phone number but it is highly recommended, if none provided the email will be generated as \'{ulid}@your-domain.tld\'. In that case, please specify at least one metadata in order to find your entry with ease.
     * @summary Register a Persona (Your customer)
     * @param {PersonaWrite} personaWrite The new Persona resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonaApi
     */
    public apiPersonasPost(personaWrite: PersonaWrite, options?: RawAxiosRequestConfig) {
        return PersonaApiFp(this.configuration).apiPersonasPost(personaWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionGenderEnum {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    RatherNotSay = 'RATHER_NOT_SAY'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiPersonasGetCollectionOrderCreatedAtEnum {
    Asc = 'asc',
    Desc = 'desc'
}


/**
 * SafeCheckoutApi - axios parameter creator
 * @export
 */
export const SafeCheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Search amongst Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {string} [unitPrice] 
         * @param {Array<string>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection: async (page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (publicUrl2) {
                localVarQueryParameter['publicUrl[]'] = publicUrl2;
            }

            if (unitPrice !== undefined) {
                localVarQueryParameter['unitPrice'] = unitPrice;
            }

            if (unitPrice2) {
                localVarQueryParameter['unitPrice[]'] = unitPrice2;
            }

            if (itemCount !== undefined) {
                localVarQueryParameter['itemCount'] = itemCount;
            }

            if (itemCount2) {
                localVarQueryParameter['itemCount[]'] = itemCount2;
            }

            if (createdAtBefore !== undefined) {
                localVarQueryParameter['createdAt[before]'] = createdAtBefore;
            }

            if (createdAtStrictlyBefore !== undefined) {
                localVarQueryParameter['createdAt[strictly_before]'] = createdAtStrictlyBefore;
            }

            if (createdAtAfter !== undefined) {
                localVarQueryParameter['createdAt[after]'] = createdAtAfter;
            }

            if (createdAtStrictlyAfter !== undefined) {
                localVarQueryParameter['createdAt[strictly_after]'] = createdAtStrictlyAfter;
            }

            if (metadata) {
                localVarQueryParameter['metadata[]'] = metadata.join(COLLECTION_FORMATS.csv);
            }

            if (offerMetadata) {
                localVarQueryParameter['offer.metadata[]'] = offerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (sellerMetadata) {
                localVarQueryParameter['seller.metadata[]'] = sellerMetadata.join(COLLECTION_FORMATS.csv);
            }

            if (nature !== undefined) {
                localVarQueryParameter['nature'] = nature;
            }

            if (condition !== undefined) {
                localVarQueryParameter['condition'] = condition;
            }

            if (shippingAllowed !== undefined) {
                localVarQueryParameter['shippingAllowed'] = shippingAllowed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a public listening Offer linked to a specific Seller
         * @summary Create a public link for Offer
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost: async (offerIndependentWrite: OfferIndependentWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offerIndependentWrite' is not null or undefined
            assertParamExists('apiOffersPost', 'offerIndependentWrite', offerIndependentWrite)
            const localVarPath = `/offers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE", "PERSONA_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerIndependentWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a Offer resource.
         * @summary Fetch a Offer details
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet: async (ulid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidGet', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your existing Offer and reuse existing generated link
         * @summary Update existing Offer
         * @param {string} ulid Offer identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidPatch: async (ulid: string, offerUpdate: OfferUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidPatch', 'ulid', ulid)
            // verify required parameter 'offerUpdate' is not null or undefined
            assertParamExists('apiOffersUlidPatch', 'offerUpdate', offerUpdate)
            const localVarPath = `/offers/{ulid}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiOffersUlidmediasIdDelete', 'id', id)
            const localVarPath = `/offers/{ulid}/medias/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost: async (ulid: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiOffersUlidmediasPost', 'ulid', ulid)
            const localVarPath = `/offers/{ulid}/medias`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Transaction
         * @param {string} ulid Evaluation identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidevaluationsPost: async (ulid: string, evaluationWrite: EvaluationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidevaluationsPost', 'ulid', ulid)
            // verify required parameter 'evaluationWrite' is not null or undefined
            assertParamExists('apiTransactionsUlidevaluationsPost', 'evaluationWrite', evaluationWrite)
            const localVarPath = `/transactions/{ulid}/evaluations`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsGetCollection: async (ulid: string, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsGetCollection', 'ulid', ulid)
            const localVarPath = `/transactions/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsIdDelete: async (ulid: string, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsIdDelete', 'ulid', ulid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsIdDelete', 'id', id)
            const localVarPath = `/transactions/{ulid}/parcels/{id}`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsPost: async (ulid: string, parcelWrite: ParcelWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ulid' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsPost', 'ulid', ulid)
            // verify required parameter 'parcelWrite' is not null or undefined
            assertParamExists('apiTransactionsUlidparcelsPost', 'parcelWrite', parcelWrite)
            const localVarPath = `/transactions/{ulid}/parcels`
                .replace(`{${"ulid"}}`, encodeURIComponent(String(ulid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["OFFER_WRITE"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(parcelWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SafeCheckoutApi - functional programming interface
 * @export
 */
export const SafeCheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SafeCheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Search amongst Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {string} [unitPrice] 
         * @param {Array<string>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfferCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, sellerMetadata, nature, condition, shippingAllowed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a public listening Offer linked to a specific Seller
         * @summary Create a public link for Offer
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersPost(offerIndependentWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a Offer resource.
         * @summary Fetch a Offer details
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidGet(ulid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update your existing Offer and reuse existing generated link
         * @summary Update existing Offer
         * @param {string} ulid Offer identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidPatch(ulid: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfferPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidPatch(ulid, offerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasIdDelete(ulid, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidmediasIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOffersUlidmediasPost(ulid, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiOffersUlidmediasPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Transaction
         * @param {string} ulid Evaluation identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidevaluationsPost(ulid, evaluationWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidevaluationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsGetCollection(ulid, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidparcelsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsIdDelete(ulid, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidparcelsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTransactionsUlidparcelsPost(ulid, parcelWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SafeCheckoutApi.apiTransactionsUlidparcelsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SafeCheckoutApi - factory interface
 * @export
 */
export const SafeCheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SafeCheckoutApiFp(configuration)
    return {
        /**
         * Retrieves the collection of Offer resources.
         * @summary Search amongst Offers
         * @param {number} [page] The collection page number
         * @param {string} [title] 
         * @param {string} [publicUrl] 
         * @param {Array<string>} [publicUrl2] 
         * @param {string} [unitPrice] 
         * @param {Array<string>} [unitPrice2] 
         * @param {number} [itemCount] 
         * @param {Array<number>} [itemCount2] 
         * @param {string} [createdAtBefore] 
         * @param {string} [createdAtStrictlyBefore] 
         * @param {string} [createdAtAfter] 
         * @param {string} [createdAtStrictlyAfter] 
         * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
         * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
         * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
         * @param {boolean} [shippingAllowed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: any): AxiosPromise<Array<OfferCollectionRead>> {
            return localVarFp.apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, sellerMetadata, nature, condition, shippingAllowed, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a public listening Offer linked to a specific Seller
         * @summary Create a public link for Offer
         * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: any): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiOffersPost(offerIndependentWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a Offer resource.
         * @summary Fetch a Offer details
         * @param {string} ulid Offer identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidGet(ulid: string, options?: any): AxiosPromise<OfferRead> {
            return localVarFp.apiOffersUlidGet(ulid, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your existing Offer and reuse existing generated link
         * @summary Update existing Offer
         * @param {string} ulid Offer identifier
         * @param {OfferUpdate} offerUpdate The updated Offer resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidPatch(ulid: string, offerUpdate: OfferUpdate, options?: any): AxiosPromise<OfferPostCreationRead> {
            return localVarFp.apiOffersUlidPatch(ulid, offerUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Removes the Media resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload a picture for a given Offer
         * @param {string} ulid 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOffersUlidmediasPost(ulid: string, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiOffersUlidmediasPost(ulid, file, options).then((request) => request(axios, basePath));
        },
        /**
         * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
         * @summary Submit an Evaluation for the Transaction
         * @param {string} ulid Evaluation identifier
         * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: any): AxiosPromise<EvaluationRead> {
            return localVarFp.apiTransactionsUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of Parcel resources.
         * @summary Retrieves the collection of Parcel resources.
         * @param {string} ulid 
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.apiTransactionsUlidparcelsGetCollection(ulid, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Parcel resource.
         * @summary Removes the Parcel resource.
         * @param {string} ulid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsIdDelete(ulid: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiTransactionsUlidparcelsIdDelete(ulid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Parcel resource.
         * @summary Creates a Parcel resource.
         * @param {string} ulid 
         * @param {ParcelWrite} parcelWrite The new Parcel resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: any): AxiosPromise<object> {
            return localVarFp.apiTransactionsUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SafeCheckoutApi - object-oriented interface
 * @export
 * @class SafeCheckoutApi
 * @extends {BaseAPI}
 */
export class SafeCheckoutApi extends BaseAPI {
    /**
     * Retrieves the collection of Offer resources.
     * @summary Search amongst Offers
     * @param {number} [page] The collection page number
     * @param {string} [title] 
     * @param {string} [publicUrl] 
     * @param {Array<string>} [publicUrl2] 
     * @param {string} [unitPrice] 
     * @param {Array<string>} [unitPrice2] 
     * @param {number} [itemCount] 
     * @param {Array<number>} [itemCount2] 
     * @param {string} [createdAtBefore] 
     * @param {string} [createdAtStrictlyBefore] 
     * @param {string} [createdAtAfter] 
     * @param {string} [createdAtStrictlyAfter] 
     * @param {Array<string>} [metadata] Flattened OrderedMap for metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [offerMetadata] Flattened OrderedMap for offer.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {Array<string>} [sellerMetadata] Flattened OrderedMap for seller.metadata. Must be a multiple of two items count. Explicitly set \&quot;null\&quot; for desired value.
     * @param {ApiOffersGetCollectionNatureEnum} [nature] Filter on a limited subset of nature
     * @param {ApiOffersGetCollectionConditionEnum} [condition] Filter on a limited subset of condition
     * @param {boolean} [shippingAllowed] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersGetCollection(page?: number, title?: string, publicUrl?: string, publicUrl2?: Array<string>, unitPrice?: string, unitPrice2?: Array<string>, itemCount?: number, itemCount2?: Array<number>, createdAtBefore?: string, createdAtStrictlyBefore?: string, createdAtAfter?: string, createdAtStrictlyAfter?: string, metadata?: Array<string>, offerMetadata?: Array<string>, sellerMetadata?: Array<string>, nature?: ApiOffersGetCollectionNatureEnum, condition?: ApiOffersGetCollectionConditionEnum, shippingAllowed?: boolean, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersGetCollection(page, title, publicUrl, publicUrl2, unitPrice, unitPrice2, itemCount, itemCount2, createdAtBefore, createdAtStrictlyBefore, createdAtAfter, createdAtStrictlyAfter, metadata, offerMetadata, sellerMetadata, nature, condition, shippingAllowed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a public listening Offer linked to a specific Seller
     * @summary Create a public link for Offer
     * @param {OfferIndependentWrite} offerIndependentWrite The new Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersPost(offerIndependentWrite: OfferIndependentWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersPost(offerIndependentWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a Offer resource.
     * @summary Fetch a Offer details
     * @param {string} ulid Offer identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidGet(ulid: string, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidGet(ulid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your existing Offer and reuse existing generated link
     * @summary Update existing Offer
     * @param {string} ulid Offer identifier
     * @param {OfferUpdate} offerUpdate The updated Offer resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidPatch(ulid: string, offerUpdate: OfferUpdate, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidPatch(ulid, offerUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Removes the Media resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload a picture for a given Offer
     * @param {string} ulid 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiOffersUlidmediasPost(ulid: string, file?: File, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiOffersUlidmediasPost(ulid, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Only authenticated** complainant and seller **CAN** issue an evaluation **WHEN** the transaction reached a final state.
     * @summary Submit an Evaluation for the Transaction
     * @param {string} ulid Evaluation identifier
     * @param {EvaluationWrite} evaluationWrite The new Evaluation resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidevaluationsPost(ulid: string, evaluationWrite: EvaluationWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidevaluationsPost(ulid, evaluationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of Parcel resources.
     * @summary Retrieves the collection of Parcel resources.
     * @param {string} ulid 
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsGetCollection(ulid: string, page?: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsGetCollection(ulid, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Parcel resource.
     * @summary Removes the Parcel resource.
     * @param {string} ulid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsIdDelete(ulid: string, id: number, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsIdDelete(ulid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Parcel resource.
     * @summary Creates a Parcel resource.
     * @param {string} ulid 
     * @param {ParcelWrite} parcelWrite The new Parcel resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SafeCheckoutApi
     */
    public apiTransactionsUlidparcelsPost(ulid: string, parcelWrite: ParcelWrite, options?: RawAxiosRequestConfig) {
        return SafeCheckoutApiFp(this.configuration).apiTransactionsUlidparcelsPost(ulid, parcelWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionNatureEnum {
    Service = 'service',
    PhysicalItem = 'physical_item',
    DematerializedItem = 'dematerialized_item',
    RentItem = 'rent_item'
}
/**
  * @export
  * @enum {string}
  */
export enum ApiOffersGetCollectionConditionEnum {
    New = 'NEW',
    Used = 'USED',
    Damaged = 'DAMAGED',
    Deteriorated = 'DETERIORATED',
    Unrecoverable = 'UNRECOVERABLE'
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierDelete', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet: async (identifier: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('apiApiClientsIdentifierGet', 'identifier', identifier)
            const localVarPath = `/api-clients/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost: async (apiClientWrite: ApiClientWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiClientWrite' is not null or undefined
            assertParamExists('apiApiClientsPost', 'apiClientWrite', apiClientWrite)
            const localVarPath = `/api-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiClientWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost: async (userInvite: UserInvite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvite' is not null or undefined
            assertParamExists('apiInvitePost', 'userInvite', userInvite)
            const localVarPath = `/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Internal-use only, protected by a captcha. User first-enrollment
         * @summary Customer onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost: async (userWrite: UserWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWrite' is not null or undefined
            assertParamExists('apiRegisterPost', 'userWrite', userWrite)
            const localVarPath = `/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection: async (page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch: async (id: string, userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('apiUsersIdPatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdavatarDelete', 'id', id)
            const localVarPath = `/users/{id}/avatar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarPost: async (id: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdavatarPost', 'id', id)
            const localVarPath = `/users/{id}/avatar`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailPatch: async (id: string, userUserEmailUpdate: UserUserEmailUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailPatch', 'id', id)
            // verify required parameter 'userUserEmailUpdate' is not null or undefined
            assertParamExists('apiUsersIdemailPatch', 'userUserEmailUpdate', userUserEmailUpdate)
            const localVarPath = `/users/{id}/email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUserEmailUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch: async (id: string, userEmailValidationWrite: UserEmailValidationWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'id', id)
            // verify required parameter 'userEmailValidationWrite' is not null or undefined
            assertParamExists('apiUsersIdemailValidationPatch', 'userEmailValidationWrite', userEmailValidationWrite)
            const localVarPath = `/users/{id}/email-validation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userEmailValidationWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdenablePatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdenablePatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIdenablePatch', 'body', body)
            const localVarPath = `/users/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdpasswordPatch: async (id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdpasswordPatch', 'id', id)
            // verify required parameter 'userUserPasswordUpdate' is not null or undefined
            assertParamExists('apiUsersIdpasswordPatch', 'userUserPasswordUpdate', userUserPasswordUpdate)
            const localVarPath = `/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUserPasswordUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpSetupPatch: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdtotpSetupPatch', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiUsersIdtotpSetupPatch', 'body', body)
            const localVarPath = `/users/{id}/totp-setup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpTogglePatch: async (id: string, userTotpToggleWrite: UserTotpToggleWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUsersIdtotpTogglePatch', 'id', id)
            // verify required parameter 'userTotpToggleWrite' is not null or undefined
            assertParamExists('apiUsersIdtotpTogglePatch', 'userTotpToggleWrite', userTotpToggleWrite)
            const localVarPath = `/users/{id}/totp-toggle`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTotpToggleWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost: async (userJwtWrite?: UserJwtWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication personaAuthKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Persona-Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userJwtWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiClientRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierDelete(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsIdentifierDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsIdentifierGet(identifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsIdentifierGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiClientPostCreationRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiApiClientsPost(apiClientWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiApiClientsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInvitePost(userInvite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiInvitePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAuthenticatedRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Internal-use only, protected by a captcha. User first-enrollment
         * @summary Customer onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRegisterPost(userWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersGetCollection(page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSupportRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdPatch(id, userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdavatarDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdavatarDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdavatarPost(id, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdavatarPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailPatch(id, userUserEmailUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdemailPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPostRegisterRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdemailValidationPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserSubscribed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdenablePatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdenablePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdpasswordPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTotpSetupRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdtotpSetupPatch(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdtotpSetupPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.apiUsersIdtotpTogglePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserJwtCreated>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationPost(userJwtWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.authenticationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Retrieves the collection of ApiClient resources.
         * @summary Retrieves the collection of ApiClient resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsGetCollection(page?: number, options?: any): AxiosPromise<Array<ApiClientRead>> {
            return localVarFp.apiApiClientsGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the ApiClient resource.
         * @summary Removes the ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierDelete(identifier: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiApiClientsIdentifierDelete(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a ApiClient resource.
         * @summary Retrieves a ApiClient resource.
         * @param {string} identifier ApiClient identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsIdentifierGet(identifier: string, options?: any): AxiosPromise<ApiClientRead> {
            return localVarFp.apiApiClientsIdentifierGet(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a ApiClient resource.
         * @summary Creates a ApiClient resource.
         * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: any): AxiosPromise<ApiClientPostCreationRead> {
            return localVarFp.apiApiClientsPost(apiClientWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Invite a user to your organization workspace
         * @summary Organization invite
         * @param {UserInvite} userInvite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInvitePost(userInvite: UserInvite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiInvitePost(userInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet(options?: any): AxiosPromise<UserAuthenticatedRead> {
            return localVarFp.apiMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Internal-use only, protected by a captcha. User first-enrollment
         * @summary Customer onboarding
         * @param {UserWrite} userWrite The new User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRegisterPost(userWrite: UserWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiRegisterPost(userWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of User resources.
         * @summary Retrieves the collection of User resources.
         * @param {number} [page] The collection page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersGetCollection(page?: number, options?: any): AxiosPromise<Array<UserCollectionRead>> {
            return localVarFp.apiUsersGetCollection(page, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the User resource.
         * @summary Removes the User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a User resource.
         * @summary Retrieves a User resource.
         * @param {string} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdGet(id: string, options?: any): AxiosPromise<UserSupportRead> {
            return localVarFp.apiUsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUpdate} userUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdPatch(id, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Media resource.
         * @summary Unset your personal avatar
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUsersIdavatarDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Media resource.
         * @summary Upload your personal avatar
         * @param {number} id User identifier
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdavatarPost(id: number, file?: File, options?: any): AxiosPromise<MediaRead> {
            return localVarFp.apiUsersIdavatarPost(id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Update user email
         * @param {string} id User identifier
         * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: any): AxiosPromise<UserUserRead> {
            return localVarFp.apiUsersIdemailPatch(id, userUserEmailUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Validate email ownership
         * @param {string} id User identifier
         * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: any): AxiosPromise<UserPostRegisterRead> {
            return localVarFp.apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdenablePatch(id: string, body: object, options?: any): AxiosPromise<UserUserSubscribed> {
            return localVarFp.apiUsersIdenablePatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: any): AxiosPromise<UserUserRead> {
            return localVarFp.apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {object} body The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpSetupPatch(id: string, body: object, options?: any): AxiosPromise<UserTotpSetupRead> {
            return localVarFp.apiUsersIdtotpSetupPatch(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the User resource.
         * @summary Updates the User resource.
         * @param {string} id User identifier
         * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: any): AxiosPromise<object> {
            return localVarFp.apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
         * @summary User authentication
         * @param {UserJwtWrite} [userJwtWrite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationPost(userJwtWrite?: UserJwtWrite, options?: any): AxiosPromise<UserJwtCreated> {
            return localVarFp.authenticationPost(userJwtWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Retrieves the collection of ApiClient resources.
     * @summary Retrieves the collection of ApiClient resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the ApiClient resource.
     * @summary Removes the ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsIdentifierDelete(identifier: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsIdentifierDelete(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a ApiClient resource.
     * @summary Retrieves a ApiClient resource.
     * @param {string} identifier ApiClient identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsIdentifierGet(identifier: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsIdentifierGet(identifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a ApiClient resource.
     * @summary Creates a ApiClient resource.
     * @param {ApiClientWrite} apiClientWrite The new ApiClient resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiApiClientsPost(apiClientWrite: ApiClientWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiApiClientsPost(apiClientWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invite a user to your organization workspace
     * @summary Organization invite
     * @param {UserInvite} userInvite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiInvitePost(userInvite: UserInvite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiInvitePost(userInvite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiMeGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Internal-use only, protected by a captcha. User first-enrollment
     * @summary Customer onboarding
     * @param {UserWrite} userWrite The new User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiRegisterPost(userWrite: UserWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiRegisterPost(userWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of User resources.
     * @summary Retrieves the collection of User resources.
     * @param {number} [page] The collection page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersGetCollection(page?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersGetCollection(page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the User resource.
     * @summary Removes the User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a User resource.
     * @summary Retrieves a User resource.
     * @param {string} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserUpdate} userUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdPatch(id: string, userUpdate: UserUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdPatch(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Media resource.
     * @summary Unset your personal avatar
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdavatarDelete(id: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdavatarDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Media resource.
     * @summary Upload your personal avatar
     * @param {number} id User identifier
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdavatarPost(id: number, file?: File, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdavatarPost(id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Update user email
     * @param {string} id User identifier
     * @param {UserUserEmailUpdate} userUserEmailUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailPatch(id: string, userUserEmailUpdate: UserUserEmailUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailPatch(id, userUserEmailUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Validate email ownership
     * @param {string} id User identifier
     * @param {UserEmailValidationWrite} userEmailValidationWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdemailValidationPatch(id: string, userEmailValidationWrite: UserEmailValidationWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdemailValidationPatch(id, userEmailValidationWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdenablePatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdenablePatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserUserPasswordUpdate} userUserPasswordUpdate The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdpasswordPatch(id: string, userUserPasswordUpdate: UserUserPasswordUpdate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdpasswordPatch(id, userUserPasswordUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {object} body The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdtotpSetupPatch(id: string, body: object, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdtotpSetupPatch(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the User resource.
     * @summary Updates the User resource.
     * @param {string} id User identifier
     * @param {UserTotpToggleWrite} userTotpToggleWrite The updated User resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUsersIdtotpTogglePatch(id: string, userTotpToggleWrite: UserTotpToggleWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).apiUsersIdtotpTogglePatch(id, userTotpToggleWrite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is protected by a captcha, do not try to use it to consume our API. IP/CIDR to be banned upon fraudulent/irregular usage. Follow the oauth 2.0 authentication challenge as described in the documentation.
     * @summary User authentication
     * @param {UserJwtWrite} [userJwtWrite] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticationPost(userJwtWrite?: UserJwtWrite, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).authenticationPost(userJwtWrite, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection: async (page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-histories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (event2) {
                localVarQueryParameter['event[]'] = event2;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['objectId'] = objectId;
            }

            if (objectId2) {
                localVarQueryParameter['objectId[]'] = objectId2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdGet', 'id', id)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('apiWebhookHistoriesIdPut', 'body', body)
            const localVarPath = `/webhook-histories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection: async (page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth", ["ORGANIZATION_READ"], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsIdDelete', 'id', id)
            const localVarPath = `/webhook-subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost: async (webhookSubscriptionWrite: WebhookSubscriptionWrite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookSubscriptionWrite' is not null or undefined
            assertParamExists('apiWebhookSubscriptionsPost', 'webhookSubscriptionWrite', webhookSubscriptionWrite)
            const localVarPath = `/webhook-subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtPersonalKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSubscriptionWrite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookHistoryCollectionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookHistoryRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookHistoriesIdPut(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookHistoriesIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookSubscriptionRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsGetCollection(page, event, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsGetCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.apiWebhookSubscriptionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * Retrieves the collection of WebhookHistory resources.
         * @summary Retrieves the collection of WebhookHistory resources.
         * @param {number} [page] The collection page number
         * @param {string} [event] 
         * @param {Array<string>} [event2] 
         * @param {string} [objectId] 
         * @param {Array<string>} [objectId2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: any): AxiosPromise<Array<WebhookHistoryCollectionRead>> {
            return localVarFp.apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a WebhookHistory resource.
         * @summary Retrieves a WebhookHistory resource.
         * @param {string} id WebhookHistory identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdGet(id: string, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces the WebhookHistory resource.
         * @summary Replay a Webhook that ended up in failure
         * @param {string} id WebhookHistory identifier
         * @param {object} body The updated WebhookHistory resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookHistoriesIdPut(id: string, body: object, options?: any): AxiosPromise<WebhookHistoryRead> {
            return localVarFp.apiWebhookHistoriesIdPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the collection of WebhookSubscription resources.
         * @summary Retrieves the collection of WebhookSubscription resources.
         * @param {number} [page] The collection page number
         * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: any): AxiosPromise<Array<WebhookSubscriptionRead>> {
            return localVarFp.apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the WebhookSubscription resource.
         * @summary Removes the WebhookSubscription resource.
         * @param {string} id WebhookSubscription identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a WebhookSubscription resource.
         * @summary Subscribe to Event(s)
         * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: any): AxiosPromise<WebhookSubscriptionRead> {
            return localVarFp.apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * Retrieves the collection of WebhookHistory resources.
     * @summary Retrieves the collection of WebhookHistory resources.
     * @param {number} [page] The collection page number
     * @param {string} [event] 
     * @param {Array<string>} [event2] 
     * @param {string} [objectId] 
     * @param {Array<string>} [objectId2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesGetCollection(page?: number, event?: string, event2?: Array<string>, objectId?: string, objectId2?: Array<string>, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesGetCollection(page, event, event2, objectId, objectId2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a WebhookHistory resource.
     * @summary Retrieves a WebhookHistory resource.
     * @param {string} id WebhookHistory identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces the WebhookHistory resource.
     * @summary Replay a Webhook that ended up in failure
     * @param {string} id WebhookHistory identifier
     * @param {object} body The updated WebhookHistory resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookHistoriesIdPut(id: string, body: object, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookHistoriesIdPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the collection of WebhookSubscription resources.
     * @summary Retrieves the collection of WebhookSubscription resources.
     * @param {number} [page] The collection page number
     * @param {ApiWebhookSubscriptionsGetCollectionEventEnum} [event] Filter on a limited subset of event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsGetCollection(page?: number, event?: ApiWebhookSubscriptionsGetCollectionEventEnum, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsGetCollection(page, event, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the WebhookSubscription resource.
     * @summary Removes the WebhookSubscription resource.
     * @param {string} id WebhookSubscription identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a WebhookSubscription resource.
     * @summary Subscribe to Event(s)
     * @param {WebhookSubscriptionWrite} webhookSubscriptionWrite The new WebhookSubscription resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public apiWebhookSubscriptionsPost(webhookSubscriptionWrite: WebhookSubscriptionWrite, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).apiWebhookSubscriptionsPost(webhookSubscriptionWrite, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
  * @export
  * @enum {string}
  */
export enum ApiWebhookSubscriptionsGetCollectionEventEnum {
    OfferTransactionAuthorized = 'offer.transaction.authorized',
    OfferTransactionAccepted = 'offer.transaction.accepted',
    OfferTransactionShipped = 'offer.transaction.shipped',
    OfferTransactionDelivered = 'offer.transaction.delivered',
    OfferTransactionCompleted = 'offer.transaction.completed',
    OfferTransactionCanceled = 'offer.transaction.canceled',
    OfferTransactionDisputed = 'offer.transaction.disputed',
    OfferClosed = 'offer.closed',
    PersonaAdded = 'persona.added'
}


